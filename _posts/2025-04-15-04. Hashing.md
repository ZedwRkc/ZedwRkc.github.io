---
title: 4. 해싱
date: 2025-04-15
math: true
categories: [알고리즘] 
tags: [자료구조, 알고리즘] 
---

_해싱_ 은 효율적인 알고리즘을 구현하는 데 자주 사용되는 기술입니다. 파이썬에서 자료 구조인 `set`(집합)과 `dict`(딕셔너리)는 해싱을 기반으로 합니다.

이번 장에서는 해싱 기반의 자료 구조와 알고리즘 설계에서의 활용을 살펴봅니다. 또한 해당 자료 구조의 기반이 되는 몇 가지 이론도 다룰 것입니다.

# 집합 (Set)

해싱을 기반으로 하는 파이썬 자료 구조 `set`은 요소들의 집합을 유지합니다. 이 자료 구조에 대한 연산은 다음과 같습니다.

*   메서드 `add`는 집합에 요소를 추가합니다.
*   연산자 `in`은 주어진 요소가 집합에 있는지 확인합니다.
*   메서드 `remove`는 집합에서 요소를 제거합니다.

이 자료 구조는 위의 모든 연산이 $O(1)$ 시간에 수행되도록 구현되어 있습니다.

## 예시

다음 코드는 `numbers`라는 집합을 생성하고 집합에 요소를 추가합니다.

```python
numbers = set()

numbers.add(1)
numbers.add(2)
numbers.add(3)

print(numbers) # {1, 2, 3}    
```

리스트에서 직접 집합을 생성할 수도 있습니다.

```python
numbers = set([1, 2, 3])

print(numbers) # {1, 2, 3}    
```

연산자 `in`은 요소가 집합에 있는지 테스트합니다.

```python
print(3 in numbers) # True
print(4 in numbers) # False    
```

그리고 메서드 `remove`를 사용하여 집합에서 요소를 제거할 수 있습니다.

```python
print(numbers) # {1, 2, 3}
numbers.remove(2)
print(numbers) # {1, 3}    
```

## 리스트 vs. 집합

리스트와 집합은 모두 요소들의 컬렉션을 유지하고 추가 및 제거를 지원한다는 점에서 유사한 자료 구조입니다. 그러나 효율성과 기타 속성에서 상당한 차이가 있습니다.

## 효율성

리스트에 요소를 추가하는 것은 효율적이지만, 요소를 찾고 제거하는 것은 느릴 수 있습니다.

집합의 경우, 요소를 추가하고, 찾고, 제거하는 모든 연산이 효율적입니다.

| 연산  | 리스트 | 집합  |
| --- | --- | --- |
| 추가 (`append`/`add`) | $O(1)$ | $O(1)$ |
| 찾기 (`in`) | $O(n)$ | $O(1)$ |
| 제거 (`remove`) | $O(n)$ | $O(1)$ |

## 인덱싱

리스트에서는 인덱스를 사용하여 요소에 접근할 수 있습니다.

```python
numbers = [1, 2, 3]
print(numbers[1]) # 2    
```

집합은 인덱싱을 지원하지 않습니다.

```python
numbers = set([1, 2, 3])
print(numbers[1]) # TypeError: 'set' object is not subscriptable    
```

### 중복된 요소

리스트에서는 요소가 여러 번 나타날 수 있습니다.

```python
numbers = []

numbers.append(5)
numbers.append(5)
numbers.append(5)

print(numbers) # [5, 5, 5]    
```

집합은 요소를 최대 한 번만 포함합니다. 이미 집합에 있는 요소를 추가해도 아무런 효과가 없습니다.

```python
numbers = set()

numbers.add(5)
numbers.add(5)
numbers.add(5)

print(numbers) # {5}    
```

# 예시: 서로 다른 숫자는 몇 개?

> ## 과제
숫자 리스트가 주어졌을 때, 이 리스트에 포함된 서로 다른 숫자의 개수는 몇 개입니까?<br>
<br>예를 들어, 리스트가 $\[3, 1, 2, 1, 5, 2, 2, 3\]$일 때, 원하는 답은 $4$인데, 서로 다른 숫자는 $$1$, $2$, $3$, $5$이기 때문입니다.

## 느린 해결책 (리스트)

리스트를 사용하여 다음과 같이 과제를 해결할 수 있습니다.

```python
def count_distinct(numbers):
    seen = []
    for x in numbers:
        if x not in seen:
            seen.append(x)
    return len(seen)    
```

이 알고리즘은 숫자를 순회하면서 아직 `seen` 리스트에 없는 숫자를 추가합니다. 마지막에 `seen` 리스트의 길이가 원하는 답이 됩니다.

이 알고리즘은 정확하지만 효율적이지 않습니다. 루프의 각 반복에서 $O(n)$ 시간이 걸릴 수 있는 연산자 `in`을 호출하기 때문입니다. 따라서 알고리즘의 시간 복잡도는 $O(n^2)$입니다. 그러나 리스트 대신 집합을 사용하면 간단하게 성능을 향상시킬 수 있습니다.

## 효율적인 해결책 (집합)

집합을 활용하여 이 문제를 다음과 같이 효율적으로 풀 수 있습니다:

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        if x not in seen:
            seen.add(x)
    return len(seen)    
```

이 함수는 앞의 함수와 거의 동일합니다. 유일한 차이점은 `seen`을 리스트 대신 집합으로 정의하고 `append` 대신 메서드 `add`를 사용한다는 것입니다. 이 변경은 알고리즘의 효율성에 큰 영향을 미칩니다. 변경 후 연산자 `in`은 $O(1)$ 시간만 걸리므로 알고리즘의 시간 복잡도는 $O(n)$입니다.

집합은 중복된 요소를 포함하지 않는다는 사실을 이용하여 코드를 더 단순화할 수 있습니다. 따라서 요소가 이미 집합에 있는지 확인하는 검사를 제거할 수 있습니다.

```python
def count_distinct(numbers):
    seen = set()
    for x in numbers:
        seen.add(x)
    return len(seen)    
```

리스트에서 직접 집합을 생성하여 코드를 더 줄일 수 있습니다. 한 줄만 필요합니다.

```python
def count_distinct(numbers):
    return len(set(numbers))    
```

# 딕셔너리

파이썬 자료 구조인 `dict` 또는 딕셔너리는 해싱을 기반으로 하며 키-값 쌍을 저장합니다. 아이디어는 키를 사용하여 연결된 값을 검색할 수 있다는 것입니다.

딕셔너리는 리스트의 일반화로 볼 수 있습니다. 리스트에서 키는 인덱스 $0 \\dots n$이지만, 딕셔너리에서는 키가 임의의 객체가 될 수 있습니다.

키를 사용하여 데이터를 추가, 접근 및 제거하는 데 $O(1)$ 시간이 걸립니다.

## 예시

다음 코드는 키가 문자열이고 값이 숫자인 딕셔너리 `weights`를 생성합니다.

```python
weights = {}

weights["apina"] = 100
weights["banaani"] = 1
weights["cembalo"] = 500    
```

동일한 딕셔너리를 다음과 같이 생성할 수도 있습니다.

```python
weights = {"apina": 100, "banaani": 1, "cembalo": 500}    
```

딕셔너리의 값은 리스트의 요소와 같은 방식으로 사용할 수 있습니다.

```python
print(weights["apina"]) # 100
weights["apina"] = 150
print(weights["apina"]) # 150    
```

연산자 `in`은 주어진 키가 딕셔너리에 있는지 확인합니다.

```python
print("apina" in weights) # True
print("ananas" in weights) # False    
```

명령어 `del`은 딕셔너리에서 키와 연결된 값을 제거합니다.

```python
print(weights) # {'apina': 100, 'banaani': 1, 'cembalo': 500}
del weights["banaani"]
print(weights) # {'apina': 100, 'cembalo': 500}    
```

# 딕셔너리 사용

다음으로 알고리즘 설계에서 딕셔너리를 사용하는 세 가지 일반적인 방법을 살펴보겠습니다.

## 요소가 발생했는지 여부

딕셔너리는 집합과 유사하게 이미 본 요소를 추적하는 데 사용할 수 있습니다.

```python
seen = {}
for x in items:
    seen[x] = True    
```

이 코드는 다음 코드와 거의 동일한 기능을 수행합니다.

```python
seen = set()
for x in items:
    seen.add(x)    
```

실제로 집합은 각 키가 값 `True` (또는 임의의 고정 값)와 연결된 딕셔너리의 특별한 경우로 볼 수 있습니다.

## 발생 횟수 세기

딕셔너리의 일반적인 용도는 요소 발생 횟수를 세는 것입니다.

```python
count = {}
for x in items:
    if x not in count:
        count[x] = 0
    count[x] += 1    
```

이 코드는 `count` 딕셔너리를 사용하여 각 요소의 발생 횟수를 셉니다. 요소가 아직 딕셔너리에 없으면 초기 발생 횟수가 0인 값과 함께 해당 요소를 키로 추가합니다. 그런 다음 요소가 발생할 때마다 해당 키의 값을 1씩 증가시킵니다.

## 발생 위치

일부 알고리즘에서는 각 요소가 발생한 위치를 추적하는 것이 유용합니다.

```python
pos = {}
for i, x in enumerate(items):
    pos[x] = i    
```

여기서 `pos` 딕셔너리는 각 요소의 가장 최근 발생 인덱스를 저장합니다. 함수 `enumerate`를 사용하여 코드는 리스트 `items`를 순회하므로 각 반복에서 `i`는 요소의 인덱스이고 `x`는 요소 자체입니다.

# 예시: 최빈값

>## 과제
숫자 리스트가 주어졌을 때, 리스트에서 가장 자주 나타나는 숫자인 **최빈값**을 계산하는 것입니다. 최빈값이 유일하지 않으면 가장 자주 나타나는 숫자 중 하나를 선택할 수 있습니다.<br>
<br>
예를 들어, 리스트가 $\[1, 2, 3, 2, 2, 3, 2, 2\]$일 때, 원하는 답은 $2$입니다.

딕셔너리를 사용하여 각 항목의 등장 횟수를 세면 해당 작업을 효율적으로 처리할 수 있습니다:

```python
def find_mode(numbers):
    count = {}
    mode = numbers[0]

    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1

        if count[x] > count[mode]:
            mode = x

    return mode    
```

여기서 `count`는 각 요소의 발생 횟수를 저장하는 딕셔너리이고, 변수 `mode`는 지금까지 본 요소 중 최빈값을 저장합니다. 초기에는 `mode`가 리스트의 첫 번째 숫자이며, 요소의 업데이트된 발생 횟수가 현재 최빈값의 횟수를 초과할 때마다 업데이트됩니다. 딕셔너리 연산은 $O(1)$ 시간이 걸리므로 알고리즘의 시간 복잡도는 $O(n)$입니다.


알고리즘을 구현하는 또 다른 방법은 다음과 같습니다:

```python
def find_mode(numbers):
    count = {}
    mode = (0, 0)

    for x in numbers:
        if x not in count:
            count[x] = 0
        count[x] += 1

        mode = max(mode, (count[x], x))

    return mode[1]    
```

이제 변수 `mode`는 쌍이며, 첫 번째 요소는 최빈값의 발생 횟수이고 두 번째 요소는 최빈값 자체입니다. 예를 들어, 값 `(5, 2)`는 숫자 `2`가 `5`번 발생했음을 의미합니다.

이 구현의 장점은 함수 `max`를 사용하여 최빈값을 업데이트할 수 있다는 것입니다. 여기서 `max`는 쌍의 첫 번째 요소를 주요 비교 키로 사용하고 두 번째 요소를 보조 비교 키로 사용합니다. 첫 번째 요소가 발생 횟수이므로 더 큰 횟수를 가진 쌍이 `max`에 의해 선택됩니다.

두 함수는 최빈값에 대한 여러 선택 사항이 있을 때 다르게 작동할 수 있습니다. 첫 번째 함수는 최종 횟수에 먼저 도달한 최빈값을 선택합니다. 두 번째 함수는 최빈값의 값이 보조 비교 키로 사용되기 때문에 가장 큰 값을 가진 최빈값을 선택합니다.

# 예시: 라운드

>## 과제
$1, 2, ..., n$의 숫자를 임의의 순서로 포함하는 리스트가 주어졌을 때, 각 라운드마다 왼쪽에서 오른쪽으로 리스트를 순회하면서 가장 작은 수부터 가장 큰 수 순서로 모든 숫자를 수집해야 합니다. 몇 라운드가 필요합니까?<br>
<br>
예를 들어, 리스트 $\[3, 6, 1, 7, 5, 2, 4, 8\]$은 $4$라운드가 필요합니다. 첫 번째 라운드에서는 숫자 $1$과 $2$를 수집하고, 두 번째 라운드에서는 숫자 $3$과 $4$를, 세 번째 라운드에서는 숫자 $5$를, 네 번째 라운드에서는 숫자 $6$, $7$, $8$을 수집합니다.<br>

유용한 관찰은 다음에 수집해야 할 숫자가 가장 최근에 수집한 숫자보다 왼쪽에 있을 때마다 새 라운드가 시작된다는 것입니다. 위의 예시 리스트에서 숫자 $3$은 숫자 $2$의 왼쪽에 있기 때문에 새 라운드를 시작합니다.

## 느린 해결책 (리스트)

```python
def count_rounds(numbers):
    n = len(numbers)

    rounds = 1
    for i in range(1, n):
        if numbers.index(i + 1) < numbers.index(i):
            rounds += 1

    return rounds    
```

여기서 라운드 수는 초기값이 1인 변수 `rounds`에 계산됩니다. 그런 다음 루프는 숫자 $1...n-1$까지 순회하며 숫자 $i+1$이 숫자 $i$의 왼쪽에 나타날 때마다 `rounds`를 증가시킵니다.

이 구현은 숫자의 위치를 찾는 데 메서드 `index`를 사용합니다. `index` 메서드는 $O(n)$ 시간이 걸리므로 알고리즘의 총 시간 복잡도는 $O(n^2)$이 되어 알고리즘이 느립니다.

## 효율적인 해결책 (딕셔너리)

딕셔너리를 사용하여 각 숫자의 위치를 찾으면 동일한 아이디어를 효율적으로 구현할 수 있습니다:

```python
def count_rounds(numbers):
    n = len(numbers)

    pos = {}
    for i, x in enumerate(numbers):
        pos[x] = i

    rounds = 1
    for i in range(1, n):
        if pos[i + 1] < pos[i]:
            rounds += 1

    return rounds    
```

이제 숫자의 위치를 찾는 데 $O(1)$ 시간만 필요합니다. 알고리즘에는 각각 $O(n)$ 시간이 걸리는 두 개의 별도 루프가 있으므로 알고리즘의 총 시간 복잡도는 $O(n)$입니다.

# 예시: 재생 목록

>## 과제
각 노래가 정수로 표현된 재생 목록이 주어졌을 때, 같은 노래가 두 번 이상 포함되지 않은 가장 긴 재생 목록 부분의 길이를 찾는 것입니다.<br>
<br>
예를 들어, 재생 목록이 $\[1, 2, 1, 3, 5, 4, 3, 1\]$일 때, 원하는 답은 $\[2, 1, 3, 5, 4\]$의 길이인 5입니다.

이 작업에 대한 좋은 접근 방식은 재생 목록의 각 위치에 대해 해당 위치에서 끝나는 가장 긴 반복되지 않는 부분의 길이를 계산하는 것입니다. 이러한 길이의 최댓값이 최종 답입니다. 위의 예시 재생 목록의 경우, 이러한 길이는 다음과 같습니다.

| 노래  | 1   | 2   | 1   | 3   | 5   | 4   | 3   | 1   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 길이  | 1   | 2   | 2   | 3   | 4   | 5   | 3   | 4   |

재생 목록의 주어진 위치에 있고 이전에 발생한 노래를 만날 때, 해당 노래의 이전 발생은 해당 부분에 나타날 수 없으므로 반복되지 않는 부분의 길이가 줄어들 수 있습니다. 따라서 반복되지 않는 부분은 가장 가까운 이전 발생 이후에만 시작할 수 있습니다. 이 원리를 사용하여 반복되지 않는 부분의 가장 빠른 가능한 시작 위치를 파악할 수 있습니다.

다음의 효율적인 알고리즘은 이러한 아이디어를 구현합니다.

```python
def max_length(songs):
    n = len(songs)

    pos = {}
    start = 0
    length = 0

    for i, song in enumerate(songs):
        if song in pos:
            start = max(start, pos[song] + 1)
        length = max(length, i - start + 1)
        pos[song] = i

    return length    
```

딕셔너리 `pos`는 각 노래의 마지막 발생 위치를 저장합니다. 변수 `start`는 현재 위치에서 끝나는 반복되지 않는 부분의 가장 빠른 가능한 시작 위치를 추적하고, 변수 `length`는 지금까지 찾은 가장 긴 반복되지 않는 재생 목록 부분의 길이입니다.

알고리즘은 재생 목록을 순회하면서 이전에 본 노래를 만날 때마다 `start`를 업데이트합니다. 이러한 경우, 노래의 반복을 피하기 위해 `start` 값이 증가할 수 있습니다.

해싱 기반의 효율적인 딕셔너리 연산 덕분에 알고리즘의 시간 복잡도는 $O(n)$입니다.

# 예시: 리스트 합

>## 과제
$n$개의 정수를 포함하는 리스트가 주어졌을 때, 리스트의 부분 리스트 중 요소의 합이 $x$인 부분 리스트의 개수를 세는 것입니다.<br>
<br>
예를 들어, 리스트가 $\[2, 3, 5, -3, 4, 4, 6, 2\]$이고 $x=5$일 때, 원하는 답은 $4$입니다. 합이 $x$인 부분 리스트는 $\[2, 3\]$, $\[5\]$, $\[3, 5, -3\]$, $\[-3, 4, 4\]$입니다.

이러한 종류의 작업에서 유용한 기술은 리스트의 접두사 합을 고려하는 것입니다. 즉, 각 위치에 대해 리스트의 시작부터 해당 위치까지의 숫자의 합을 계산하는 것입니다. 예시 리스트의 접두사 합은 다음과 같습니다.

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 2   | 3   | 5   | \-3 | 4   | 4   | 6   | 2   |
| 접두사 합 | 2   | 5   | 10  | 7   | 11  | 15  | 21  | 23  |

예를 들어, 위치 $4$의 접두사 합은 $11$인데, 이는 위치 $0$부터 위치 $4$까지의 숫자의 합이 $2 + 3 + 5 + (-3) + 4 = 11$이기 때문입니다.

접두사 합이 주어지면, 임의의 부분 리스트 합은 두 접두사 합의 차이로 효율적으로 계산할 수 있습니다. 부분 리스트가 위치 $a$에서 시작하여 위치 $b$에서 끝나면, 부분 리스트 합은 위치 $b$의 접두사 합에서 위치 $a-1$의 접두사 합을 빼서 얻습니다.

예시에서 위치 2에서 시작하여 위치 4에서 끝나는 부분 리스트의 부분 리스트 합은 $5 + (-3) + 4 = 6$입니다. 접두사 합을 사용하면 부분 리스트 합을 $11 - 5 = 6$으로 동일하게 계산할 수 있습니다.

다음 알고리즘은 이 기술을 기반으로 합니다.

```python
def count_sublists(numbers, x):
    count = {0: 1}
    prefix_sum = 0
    result = 0

    for i in range(len(numbers)):
        prefix_sum += numbers[i]
        if prefix_sum - x in count:
            result += count[prefix_sum - x]

        if prefix_sum not in count:
            count[prefix_sum] = 0
        count[prefix_sum] += 1

    return result    
```

여기서 딕셔너리 `count`는 각 접두사 합이 발생한 횟수를 저장하는 데 사용됩니다. 딕셔너리를 사용하면 차이가 정확히 $x$가 되도록 현재 접두사 합과 일치하는 이전 접두사 합의 개수를 효율적으로 파악할 수 있습니다. 딕셔너리는 리스트의 시작 부분에서 시작하는 부분 리스트를 고려하기 위해 빈 접두사 리스트에 해당하는 접두사 합 0으로 초기화됩니다.

결과 알고리즘의 시간 복잡도는 $O(n)$입니다.

# 해싱은 어떻게 작동하는가?

이 장의 파이썬 자료 구조인 `set`과 `dict`는 해싱과 `hash table`이라고 불리는 자료 구조에 기반을 두고 있습니다. 파이썬에서 [해시 테이블](https://tira.mooc.fi/spring-2025/hashtable)은 개방 주소화 방식으로 구현됩니다.

파이썬은 객체의 해시 값을 계산하는 데 사용되는 내장 함수 `hash`를 가지고 있습니다. 파이썬은 해시 테이블에서 객체의 위치를 결정하기 위해 이 함수를 호출합니다. 이 함수는 다음과 같이 테스트할 수 있습니다:

```

> hash(42)
42
> hash(10**100)
910685213754167845
> hash("apina")
4992529190565255982
```

위에서 볼 수 있듯이, 파이썬에서 작은 정수의 해시 값은 정수 자체입니다. 그렇지 않으면 해시 값은 무작위로 보이는 숫자입니다.

해싱에 기반한 파이썬 자료 구조는 일반적으로 효율적이며, 추가, 접근 또는 제거는 $O(1)$ 시간이 걸린다고 가정할 수 있습니다. 그러나 [특정 방식]("https://tira.mooc.fi/spring-2025/hashing-slow')으로 입력이 선택되면 해싱이 느려질 가능성이 있습니다.

# 어떤 객체를 해시할 수 있는가?

다음 코드는 파이썬에서 작동하지 않습니다:

```
lists = set()
lists.add([1, 2, 3]) # TypeError: unhashable type: 'list'
```

문제는 리스트에 대한 해시 값을 계산할 수 없다는 것입니다:

```
print(hash([1, 2, 3])) # TypeError: unhashable type: 'list'
```

파이썬의 기본 원칙은 해시 값은 _불변_  객체에 대해서만 계산할 수 있다는 것입니다. 리스트는 `append`와 같은 연산으로 변경할 수 있으므로 불변 객체가 아니며, 따라서 리스트를 해시하는 것은 불가능합니다.

파이썬의 불변 객체에는 숫자, 문자열, 불변 객체로 구성된 튜플이 포함됩니다. 예를 들어, 숫자의 튜플은 불변 객체이므로 다음 코드는 작동합니다:

```
lists = set()
lists.add((1, 2, 3))
```

딕셔너리에서 해시 값은 키에 대해서만 계산되고, 연결된 값은 해시 가능할 필요가 없다는 점에 유의하십시오. 이에 대한 예는 키가 문자열이고 값이 리스트인 다음 코드입니다:

```
lists = {}
lists["apina"] = [1, 2, 3]
```

## 자신만의 클래스에 대한 해싱

자신만의 클래스를 정의하는 경우, 다음 메소드를 정의하여 해싱을 적용할 수 있습니다:

*   `__hash__`: 객체의 해시 값을 반환합니다 (함수 `hash`가 이 메소드를 호출합니다).
*   `__eq__`: 두 객체의 내용이 동일한지 비교합니다 (연산자 `==`가 이 메소드를 호출합니다).

다음은 이러한 메소드를 정의하는 예시입니다. 여기서 메소드 `__hash__`는 객체의 내용을 나타내는 튜플의 해시 값을 반환합니다.

```python
class Location:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

    def __eq__(self, other):
        return (self.x, self.y) == (other.x, other.y)
```

이러한 정의를 사용하면 다음 코드는 예상대로 작동합니다:

```
locations = set()
locations.add(Location(1, 2))
locations.add(Location(3, -5))
locations.add(Location(1, 4))
```

## 다른 프로그래밍 언어에서의 해싱

해싱 기반의 자료 구조는 많은 프로그래밍 언어에서 사용할 수 있습니다. 종종 파이썬 딕셔너리에 해당하는 자료 구조는 _맵_  이라고 불립니다.

## C++

C++에서 자료 구조 `std::unordered_set`과 `std::unordered_map`은 해싱을 사용하여 집합과 맵을 구현합니다.

```cpp
#include <unordered_set>
#include <unordered_map>
#include <string>

std::unordered_set<int> numbers;
numbers.insert(1);
numbers.insert(2);
numbers.insert(3);

std::unordered_map<std::string, int> weights;
weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

### Java

Java에서 해당하는 자료 구조는 `HashSet`과 `HashMap`입니다:

```java

import java.util.HashSet;
import java.util.HashMap;

HashSet<Integer> numbers = new HashSet<Integer>();
numbers.add(1);
numbers.add(2);
numbers.add(3);

HashMap<String, Integer> weights = new HashMap<String, Integer>();
weights.put("apina", 100);
weights.put("banaani", 1);
weights.put("cembalo", 500);
```

### JavaScript

그리고 JavaScript에서 자료 구조 `Set`은 집합을 구현합니다:

```javascript
let numbers = new Set();

numbers.add(1);
numbers.add(2);
numbers.add(3);
```

JavaScript에서 맵을 만드는 전통적인 방법은 객체를 정의하는 것입니다:

```javascript

let weights = {};

weights["apina"] = 100;
weights["banaani"] = 1;
weights["cembalo"] = 500;
```

더 새로운 방법은 별도의 자료 구조 `Map`을 사용하는 것입니다:

```javascript

let weights = new Map();

weights.set("apina", 100);
weights.set("banaani", 1);
weights.set("cembalo", 500);
```