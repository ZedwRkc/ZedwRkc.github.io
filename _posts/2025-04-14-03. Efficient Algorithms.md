---
title: 3. 효율적인 알고리즘
date: 2025-04-14
math: true
categories: [알고리즘] 
tags: [자료구조, 알고리즘] 
---
이번 장과 다음 두 장의 주제는 효율적인 알고리즘 설계입니다. 우리는 입력 크기 $n$이 클 때도 효율적으로 실행되는 알고리즘을 목표로 합니다.

알고리즘 설계에서 흔히 발생하는 상황은 두 개의 중첩된 루프를 사용하여 $O(n^2)$ 시간 복잡도로 문제를 해결하는 간단한 알고리즘을 설계하기 쉬운 경우입니다. 이러한 종류의 알고리즘을 **무차별 대입(brute force)** 알고리즘이라고 부를 수 있습니다. 그러나 $n$이 크면 더 효율적인 알고리즘이 필요할 수 있습니다.

실제로 효율적인 알고리즘은 종종 $O(n)$ 또는 $O(n \\log n)$의 시간 복잡도를 갖는 것이 요구됩니다. 먼저 일부 추가 데이터를 유지하면서 하나의 루프에서 입력을 스캔하는 $O(n)$ 시간 복잡도 알고리즘을 살펴보겠습니다. $O(n \\log n)$ 시간 복잡도는 종종 정렬 사용에서 발생하며, 이는 5장에서 다룰 것입니다.

# 효율적인 알고리즘의 개요

일반적인 효율적인 알고리즘은 다음과 같은 구조를 가질 수 있습니다.

```
# define variables
for ...
    # efficient code
# return answer
```

효율적인 알고리즘은 일반적으로 입력을 왼쪽에서 오른쪽으로 통과하는 단일 `for` 루프를 가집니다. 루프 내부의 코드는 효율적이어서 루프의 각 반복이 $O(1)$ 시간이 걸립니다. 그러면 전체 알고리즘의 시간 복잡도는 $O(n)$이 됩니다.

효율적인 알고리즘의 루프는 다음을 포함할 수 있습니다.

*   다른 변수나 입력의 개별 요소를 사용한 변수 값 업데이트
*   변수 업데이트와 관련된 산술 표현식
*   변수 업데이트에 영향을 미치는 `if` 명령어

그러나 루프는 다음을 포함할 수 없습니다.

*   입력을 통과하는 다른 루프
*   입력을 처리하는 느린 연산 (예: `count` 또는 슬라이스 연산 `[:]`)
*   느린 함수 호출 (예: 전체 입력에 적용되는 `sum`, `min` 또는 `max`)

많은 알고리즘 설계에서 주요 Task는 루프가 효율적인 코드만 포함하도록 알고리즘을 구현하는 방법을 파악하는 것입니다. 다음으로 이를 달성하는 방법에 대한 예시를 살펴보겠습니다.


# 예시: 주식 거래

---

> ## Task
$n$일 동안의 주식 가격이 주어졌을 때, 하루에 주식을 사서 다른 날에 팔아 얻을 수 있는 가장 높은 이익을 알아내는 것입니다.<br>
다음 상황을 고려해 보세요. <br>
>>| 요일  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
>>| --- | --- | --- | --- | --- | --- | --- | --- | --- |
>>| 가격  | 3   | 7   | 5   | 1   | 4   | 6   | 2   | 3   |

>여기서 가장 높은 이익은 6 - 1 = 5이며, 3일째에 사서 5일째에 팔아서 얻을 수 있습니다.<br>

---

이 문제를 해결하는 간단한 알고리즘은 가능한 모든 매수 및 매도일 조합을 반복하는 것입니다. 다음 함수 `best_profit`은 해당 알고리즘을 구현합니다.

```python
def bestprofit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        for j in range(i + 1, n):
            best = max(best, prices[j] - prices[i])
    return best
```

변수 `i`는 매수일을 나타내고 변수 `j`는 매도일을 나타냅니다. 각 요일 조합에 대해 이익이 계산되고 변수 `best`는 지금까지 발견된 가장 높은 이익을 저장합니다. 이것은 올바른 알고리즘이지만 시간 복잡도는 $O(n^2)$이므로 큰 $n$에 대해서는 느립니다. 우리는 하나의 루프만 있는 더 효율적인 알고리즘을 원합니다.

단일 루프 알고리즘이 어떻게 작동할 수 있는지 생각해 봅시다. 루프가 특정 날짜에 도달했을 때, 그 날짜에 팔았을 경우 가능한 가장 높은 이익은 얼마일까요? 이전 날짜 중 가장 낮은 가격에 주식을 샀을 때 이익이 최대화됩니다. 따라서 가능한 각 매도일은 이전 날짜의 최저 매수 가격과 짝을 이루어야 합니다.

이 아이디어는 다음 알고리즘에 구현되어 있습니다.

```python
def bestprofit(prices):
    n = len(prices)
    best = 0
    for i in range(n):
        min_price = min(prices[0:i+1])
        best = max(best, prices[i] - min_price)
    return best
```

이제 변수 `i`는 매도일을 나타냅니다. 알고리즘은 `i`번째 날짜까지의 최저 가격을 변수 `min_price`에 계산합니다. 이는 리스트의 시작 부분인 `prices[0:i+1]`에 대해 `min` 함수를 사용하여 구현됩니다. 그런 다음 $i$번째 날짜에 팔았을 때 가능한 가장 높은 이익은 `prices[i] - min_price`로 계산할 수 있습니다.

이것은 다시 올바른 알고리즘이며 하나의 루프만 있지만 여전히 효율적이지 않습니다. 문제는 `min_price`를 계산하는 데 너무 많은 시간이 걸린다는 것입니다. `min` 함수는 이전의 모든 요소를 스캔해야 하므로 $O(n)$ 시간이 걸립니다. 본질적으로 `min` 함수 내부에 숨겨진 두 번째 루프가 있습니다. 따라서 총 시간 복잡도는 여전히 $O(n^2)$입니다.

다음과 같이 문제를 해결할 수 있습니다.

```python
def bestprofit(prices):
    n = len(prices)
    best = 0
    min_price = prices[0]
    for i in range(n):
        min_price = min(min_price, prices[i])
        best = max(best, prices[i] - min_price)
    return best
```

이제 변수 `min_price`의 값은 매번 처음부터 계산되는 것이 아니라 이전 값에서 효율적으로 계산됩니다. 이 수정으로 인해 루프의 각 반복은 $O(1)$ 시간만 필요로 하며 전체 알고리즘의 시간 복잡도는 $O(n)$이 되어 효율적입니다.

`min` 함수는 빠를 수도 있고 느릴 수도 있다는 점에 유의하세요. 긴 리스트에서 가장 작은 값을 계산하는 것은 느리지만 두 값 중 더 작은 값을 계산하는 것은 빠릅니다.

# 알고리즘이 올바른가요?

효율적인 알고리즘의 작동 논리는 종종 간단한 브루트 포스 알고리즘의 작동 논리보다 더 복잡합니다. 이로 인해 알고리즘이 올바르게 작동하는지 판단하기가 더 어려울 수 있습니다.

알고리즘의 정확성을 테스트하는 유용한 방법은 해당 알고리즘의 출력을 더 간단하고 정확한 알고리즘과 **비교**하는 것입니다. 이는 알고리즘이 많은 수의 임의 입력에 대해 테스트되도록 자동화할 수 있습니다. 예를 들어, 위의 알고리즘은 다음과 같이 테스트할 수 있습니다.

```python
import random
def best_profit_brute(prices):
    ...
def best_profit_fast(prices):
    ...

while True:
    n = random.randint(1, 20)
    prices = [random.randint(1, 10) for _ in range(n)]

    result_brute = best_profit_brute(prices)
    result_fast = best_profit_fast(prices)

    print(prices, result_brute, result_fast)

    if result_brute != result_fast:
        print("ERROR")
        break
```

여기서 함수 `best_profit_brute`는 브루트 포스 알고리즘을 구현하고 함수 `best_profit_fast`는 효율적인 알고리즘을 구현합니다. 메인 프로그램은 길이가 $1...20$ 범위이고 가격이 $1...10$ 범위인 임의의 리스트를 생성합니다. 각 테스트 실행 후 프로그램은 테스트에 사용된 리스트와 두 함수의 출력을 출력합니다. 출력은 다음과 같을 수 있습니다.

```
[2, 4, 5, 4, 2, 4, 8, 7, 5] 6 6
[8, 8, 8, 3, 6, 4, 9, 3, 2, 5, 4, 5, 2] 6 6
[9, 3, 1, 5, 8, 9, 3] 8 8
[3, 6, 7] 4 4
[6, 8, 7, 10, 8, 6, 1, 1, 2, 2, 8, 9, 10] 9 9
[4, 5, 3, 4, 5] 2 2
[3, 6, 2] 3 3
[4, 3, 8, 10, 7, 3, 4, 7, 5, 1, 7, 8, 7] 7 7
...
```

일치하는 출력은 효율적인 알고리즘의 정확성에 대한 어느 정도의 확신을 제공합니다. 프로그램이 출력이 다른 입력을 발견하면 오류를 출력하고 종료합니다. 그러면 알고리즘이 왜 잘못된 출력을 생성했는지 파악하려고 노력할 수 있습니다.

# 예시: 비트열

---

> ## Task
문자 `0`과 `1`로 구성된 비트열이 주어졌을 때, 왼쪽 위치에는 비트 `0`이 있고 오른쪽 위치에는 비트 `1`이 있도록 비트열에서 두 위치를 선택할 수 있는 방법의 수는 몇 가지입니까?<br>
다음 상황을 고려해 보세요.
>> | 위치  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 비트  | 0   | 1   | 0   | 0   | 1   | 0   | 1   | 1   |

>여기에는 그러한 위치 쌍이 12개 있습니다.

---

간단한 해결책은 가능한 모든 위치 쌍을 반복하고 왼쪽에는 '0'이 있고 오른쪽에는 '1'이 있는 횟수를 세는 것입니다.

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    for i in range(n):
        for j in range(i + 1, n):
            if bits[i] == '0' and bits[j] == '1':
                result += 1
    return result
```

다시 말하지만, 이 알고리즘은 시간 복잡도가 $O(n^2)$이므로 너무 느립니다.

하나의 루프로 이 작업을 어떻게 해결할 수 있을지 생각해 봅시다. 주식 거래 문제와 마찬가지로, 현재 위치에서 끝나는 모든 쌍을 동시에 고려하는 것이 좋은 접근 방식입니다. 더 정확히 말하면, 위치 $i$에서 위치 $i$에 비트 '1'이 있고 $i$ 이전의 위치에 비트 '0'이 있는 쌍의 수를 효율적으로 세는 방법이 필요합니다.

위치 $i$의 비트가 `0`이면 개수는 분명히 0입니다. 위치 $i$의 비트가 `1`이면 이전 위치에 `0` 비트가 몇 개 있는지 알아야 합니다. 지금까지 발견된 `0` 비트의 수를 추적하여 이 숫자를 효율적으로 얻을 수 있습니다. 다음은 이 아이디어를 구현한 것입니다.

```python
def count_ways(bits):
    n = len(bits)
    result = 0
    zeros = 0
    for i in range(len(bits)):
        if bits[i] == '0':
            zeros += 1
        if bits[i] == '1':
            result += zeros
    return result
```

루프 내에서 실행되는 코드는 현재 위치의 비트가 `0`인지 `1`인지에 따라 다릅니다. 비트가 `0`이면 지금까지 발견된 0의 수를 저장하는 변수 `zeros`를 증가시킵니다. 비트가 `1`이면 오른쪽 위치가 $i$인 원하는 쌍에 해당하는 값 `zeros`를 변수 `result`에 더합니다.

이 알고리즘은 입력을 스캔하는 단일 루프를 가지며, 루프 내부의 코드는 $O(1)$ 시간이 걸립니다. 따라서 이 알고리즘은 $O(n)$ 시간에 실행되므로 효율적입니다.

# 예시: 리스트 분할 

> ## Task
$n$개의 정수를 포함하는 리스트가 주어졌을 때, 리스트를 두 부분으로 분할하여 두 부분의 요소 합계가 동일하게 되는 방법의 수를 세는 것입니다.<br>
다음 예시 리스트를 고려해 보세요.<br>
>>| 위치  | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 1   | \-1 | 1   | \-1 | 1   | \-1 | 1   | \-1 |

>여기서 방법의 수는 3입니다. 위치 1과 2 사이, 위치 3과 4 사이, 위치 5와 6 사이에서 리스트를 분할할 수 있습니다.

다음은 이 작업을 위한 간단한 알고리즘입니다.

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    for i in range(n - 1):
        left_sum = sum(numbers[0:i+1])
        right_sum = sum(numbers[i+1:])
        if left_sum == right_sum:
            result += 1
    return result
```

이 알고리즘은 리스트를 분할하는 모든 방법을 거치면서 결과 부분의 합계를 변수 `left_sum`과 `right_sum`에 계산합니다. 합계가 같으면 변수 `result`에 저장된 개수가 1씩 증가합니다. 알고리즘의 시간 복잡도는 $O(n^2)$인데, 이는 두 합계를 계산하는 데 $O(n)$ 시간이 걸리기 때문입니다.

알고리즘이 왼쪽에서 오른쪽으로 요소를 통과하므로 각 단계에서 이전 값을 증가시켜 `left_sum`을 더 효율적으로 계산할 수 있습니다.

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    left_sum = 0
    for i in range(n - 1):
        left_sum += numbers[i]
        right_sum = sum(numbers[i+1:])
        if left_sum == right_sum:
            result += 1
    return result
```

`right_sum`을 계산하는 것은 여전히 느리고, `left_sum`에 사용한 트릭은 리스트가 왼쪽에서 오른쪽 순서로 처리되기 때문에 `right_sum`에는 작동하지 않아 여전히 충분히 빠르지 않습니다. `left_sum`의 더 빠른 계산에도 불구하고 시간 복잡도는 여전히 $O(n^2)$입니다.

더욱 개선하기 위해 다음과 같은 관찰을 활용할 수 있습니다. `left_sum` 외에도 리스트 _전체_ 의 합계를 알고 있다면 `right_sum`을 효율적으로 계산할 수 있습니다.

```python
def count_splits(numbers):
    n = len(numbers)
    result = 0
    left_sum = 0
    total_sum = sum(numbers)
    for i in range(n - 1):
        left_sum += numbers[i]
        right_sum = total_sum - left_sum
        if left_sum == right_sum:
            result += 1
    return result
```

전체 합계는 루프 동안 변경되지 않으므로 루프 전에 변수 `total_sum`에 계산할 수 있습니다. 이는 $O(n)$ 시간이 걸리지만 한 번만 수행됩니다. 그런 다음 루프 내에서 `right_sum`은 차이 `total_sum - left_sum`으로 계산할 수 있습니다. 얻어진 알고리즘의 총 시간 복잡도는 $O(n)$입니다.

# 예시: 부분 리스트

> ## 과제
$n$개의 정수를 포함하는 리스트가 주어졌을 때, 정확히 두 개의 서로 다른 정수를 포함하는 부분 리스트를 선택할 수 있는 방법의 수는 몇 가지입니까? <br>
<br>
예를 들어, 리스트 $\[1, 2, 3, 3, 2, 2, 4, 2\]$에는 그러한 부분 리스트가 14개 있습니다.

이 작업은 위의 작업보다 어렵지만, 동일한 접근 방식이 여기에도 적용됩니다. 리스트를 순회하면서 각 위치에서 현재 위치에서 끝나는 해의 수를 계산합니다.

예시 리스트를 사용하면 각 위치에서 다음과 같은 개수를 얻어야 합니다.

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 1   | 2   | 3   | 3   | 2   | 2   | 4   | 2   |
| 개수  | 0   | 1   | 1   | 1   | 3   | 3   | 2   | 3   |

예를 들어, 위치 5에서의 개수는 3인데, 이는 위치 5에서 끝나는 유효한 부분 리스트가 $\[2, 3, 3, 2, 2\]$, $\[3, 3, 2, 2\]$, $\[3, 2, 2\]$이기 때문입니다.

위치 `i`에서 끝나는 부분 리스트의 개수는 두 개의 변수 `a`와 `b`를 사용하여 효율적으로 계산할 수 있습니다. `a`는 위치 $i$의 값과 다른 값을 포함하는 가장 가까운 이전 위치를 가리키고, `b`는 위치 `i`와 `a`의 값 모두와 다른 값을 포함하는 가장 가까운 이전 위치를 가리킵니다. 이러한 두 값은 유용한데, 위치 `i`에서 끝나는 유효한 부분 리스트는 위치 `b` 다음부터 위치 `a` 이전 또는 위치 `a`까지 시작해야 하기 때문입니다. 따라서 위치 `i`에서 끝나는 유효한 부분 리스트의 수는 공식 `a - b`로 계산할 수 있습니다.

예를 들어, $i$가 위치 5에 있을 때 다음과 같은 상황이 됩니다.

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 1   | 2   | 3   | 3   | 2   | 2   | 4   | 2   |
|     |**b**     |     |     | **a**      |  | **i**      |||

여기서 `a`는 값 3을 포함하는 위치 3을 가리키고, `b`는 값 1을 포함하는 위치 0을 가리킵니다. 부분 리스트의 개수는 3 - 0 = 3으로 얻어집니다.

위치 $i$의 값이 위치 $i - 1$의 값과 다를 때마다 변수 `a`와 `b`를 업데이트해야 합니다. 고려해야 할 두 가지 경우가 있습니다.

1.  위치 $i$의 값이 `a`의 값과 다르면 `b`는 위치 `a`로 이동하고 `a`는 위치 $i - 1$로 이동합니다.
2.  위치 $i$의 값이 `a`의 값과 같으면 `a`는 다시 $i - 1$로 이동하지만 `b`는 이동하지 않습니다.

예시에서 다음에 무슨 일이 일어나는지 살펴보겠습니다. `i`가 위치 5에서 위치 6으로 이동하면 `i`와 `a`의 값이 다르고 경우 1이 발생합니다. 따라서 `a`는 위치 6 - 1 = 5로 이동하고 `b`는 위치 3으로 이동합니다.

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 1   | 2   | 3   | 3   | 2   | 2   | 4   | 2   |
|     |     |     |     | **b** |     | **a** | **i** |     |

`i`가 위치 6에서 위치 7로 이동하면 `i`와 `a`의 값이 같고 경우 2가 발생합니다. 따라서 `a`는 위치 7 - 1 = 6으로 이동하고 `b`는 이동하지 않습니다.

| 인덱스 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 숫자  | 1   | 2   | 3   | 3   | 2   | 2   | 4   | 2   |
|     |     |     |     | **b** |     |     | **a** | **i** |

이 아이디어는 다음과 같이 구현할 수 있는 효율적인 알고리즘으로 이어집니다.

```python
def count_lists(numbers):
    n = len(numbers)
    a = b = -1
    result = 0
    for i in range(1, n):
        if numbers[i] != numbers[i - 1]:
            if numbers[i] != numbers[a]:
                b = a
            a = i - 1
        result += a - b
    return result
```

초기에 `a`와 `b` 모두 `-1` 값을 가지는데, 이는 아직 어떤 리스트 위치도 가리키지 않음을 나타냅니다. `a` 또는 `b`가 여전히 `-1` 값을 가질 때 알고리즘이 시작 부분에서 올바른 부분 리스트 개수를 계산하는지 확인하는 것은 간단합니다.