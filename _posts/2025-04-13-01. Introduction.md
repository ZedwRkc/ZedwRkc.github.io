---
title: 1. 서론
date: 2025-04-13
math: true
categories: [알고리즘] 
tags: [자료구조, 알고리즘] 
---

자료 구조 및 알고리즘 강좌의 목표는 여러분의 프로그래밍 기술을 향상시키고, 어떤 상황에서도 정확하고 효율적인 프로그램을 구현하는 데 도움이 되는 기술과 사고방식을 가르치는 것입니다.
이 강좌는 파이썬 언어를 사용하지만, 강좌에서 가르치는 기술은 다른 프로그래밍 언어에도 적용할 수 있습니다. 이 강좌는 많은 프로그래밍을 포함하지만, 일부 이론적인 아이디어와 개념도 다룹니다.

<h2>알고리즘이란 무엇인가?</h2>

<b>알고리즘</b>은 어떤 계산 문제를 해결하기 위한 방법입니다. 어떤 프로그래밍 언어로 구현된 알고리즘은 컴퓨터에서 실행될 수 있습니다.
알고리즘의 <b>입력</b>은 알고리즘에 제공되는 초기 데이터입니다. 알고리즘의 <b>출력</b>은 알고리즘 실행이 끝날 때 생성되는 답입니다. 파이썬에서 알고리즘은 함수로 구현될 수 있으며, 일반적으로 입력은 함수의 매개변수로 주어지고 출력은 반환 값입니다.
예를 들어, 알고리즘에 숫자 목록이 주어지고 그 중 짝수가 몇 개인지 세는 작업을 생각해 봅시다. 예를 들어 목록이 `[5, 4, 1, 7, 9, 6]`인 경우, 원하는 답은 <b>2</b>입니다. 왜냐하면 <b>4</b>와 <b>6</b>이 짝수이기 때문입니다.
이 작업은 목록의 숫자를 순회하면서 지금까지 발견된 짝수의 개수를 저장하는 변수를 유지하는 알고리즘으로 해결할 수 있습니다. 이 알고리즘은 다음과 같은 파이썬 함수 `count_even`으로 구현될 수 있습니다.

```py
def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result
```

이 함수는 다음의 메인 프로그램으로 테스트할 수 있습니다.

```py
print(count_even([1, 2, 3])) # 1
print(count_even([2, 2, 2, 2, 2])) # 5
print(count_even([5, 4, 1, 7, 9, 6])) # 2
```

여기서 함수는 세 개의 다른 목록으로 테스트됩니다. 각 테스트마다 원하는 답이 줄 끝에 주석으로 달려 있습니다. 프로그램을 실행하면 다음과 같이 출력됩니다.

```
1
5
2
```
따라서 이 함수는 적어도 이 세 개의 목록에 대해서는 원하는 출력을 생성하며, 우리는 이 작업을 위한 올바르게 작동하는 알고리즘을 만든 것 같습니다.

<h2>자료 구조란 무엇인가?</h2>

<b>자료 구조</b>는 프로그램 내에서 데이터를 저장하는 방식입니다. 파이썬의 기본적인 자료 구조는 리스트이지만, 많은 다른 표준 자료 구조도 있습니다. 자료 구조의 선택은 알고리즘 설계의 중요한 부분인데, 왜냐하면 자료 구조는 알고리즘의 효율성에 큰 영향을 미치기 때문입니다.
이 강좌에서는 많은 자료 구조와 알고리즘 설계에서의 그 사용법에 대해 배웁니다. 우리는 많은 표준 파이썬 자료 구조를 다루고, 파이썬이나 다른 프로그래밍 언어에서 제공하지 않는 자료 구조를 구현하는 방법을 배웁니다.

<h2>알고리즘 구현하기</h2>

어떤 알고리즘이든 몇 가지 기본적인 프로그래밍 구조로 구현할 수 있습니다. 파이썬에서 이러한 기본적인 구조는 다음과 같습니다.
<ul>
    <li>변수</li>
    <li>연산자 (+, = 등)</li>
    <li>조건문 (if)</li>
    <li>반복문 (for, while)</li>
    <li>리스트</li>
    <li>함수</li>
    <li>클래스</li>
</ul>
이러한 것들 외에도 프로그래밍 언어에는 코드를 짧게 만드는 데 도움이 되지만 코드의 기본적인 작동 논리에는 영향을 미치지 않는 많은 다른 기능들이 있습니다. 이러한 기능들은 알고리즘을 구현하는 데 사용될 수 있지만 필수적인 것은 아닙니다.
기본적인 구조로 구현되었던 이전의 예시 함수 `count_even`으로 돌아가 봅시다.

```py
def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result
```
이 함수는 특별한 파이썬 구조인 제너레이터 표현식을 사용하여 더 간결하게 구현할 수 있습니다.

```py
def count_even(numbers):
    return sum(x % 2 == 0 for x in numbers)
```
여기서 `sum` 함수는 리스트의 각 요소 `x`에 대해 표현식 `x % 2 == 0`의 값을 계산하는 제너레이터 표현식을 감싸고 있습니다. 가능한 값은 `True`와 `False`이지만, 이 값들이 합산될 때 각 `True`는 숫자 1로, 각 `False`는 숫자 0으로 계산됩니다. 따라서 합산의 결과는 짝수의 개수가 됩니다.
후자의 함수는 훨씬 짧지만 기본적인 작동 방식은 전자의 함수와 동일합니다. 두 함수 모두 리스트의 숫자를 순회하면서 짝수가 발견될 때마다 횟수를 더합니다. 작동 논리는 본질적으로 두 경우 모두 같습니다.
첫 번째 함수의 장점은 파이썬의 특별한 구조에 익숙하지 않은 사람에게 설명하기 쉽다는 것입니다. 이 함수는 예를 들어 자바스크립트와 같은 다른 프로그래밍 언어로 쉽게 번역될 수 있습니다.

```js
function countEven(numbers) {
    let result = 0;
    for (let x of numbers) {
        if (x % 2 == 0) result++;
    }
    return result;
}
```
두 번째 함수의 장점은 더 간결하고 아마도 파이썬 언어의 스타일에 더 가깝다는 것입니다. 기본적인 구조로도 충분하지만, 더 많은 특별한 구조를 배우는 것도 흥미로울 수 있습니다.

<h2>알고리즘의 효율성</h2>

같은 작업을 다른 알고리즘으로 해결할 수 있으며, 그 효율성에는 큰 차이가 있을 수 있습니다. 종종 목표는 작업을 빠르게 해결하는 효율적인 알고리즘을 찾는 것입니다.
숫자 목록이 주어졌을 때, 임의의 두 숫자 사이의 가장 큰 차이를 찾는 작업을 생각해 봅시다. 예를 들어 목록이 `[3, 2, 6, 5, 8, 5]`일 때, 원하는 답은 <b>6</b>입니다. 왜냐하면 가장 큰 차이는 숫자 <b>2</b>와 <b>8</b> 사이에서 발생하기 때문입니다.
이 작업을 해결하기 위한 세 가지 알고리즘이 아래에 제시되어 있습니다.

<h3>알고리즘 1</h3>
```py
def max_diff(numbers):
    result = 0
    for x in numbers:
        for y in numbers:
            result = max(result, abs(x - y))
    return result
```
첫 번째 알고리즘은 리스트에서 두 숫자를 선택하는 모든 방법을 순회하는 두 개의 중첩된 `for` 루프를 가지고 있습니다. 이 알고리즘은 `abs` (절댓값) 함수를 사용하여 차이를 계산하고 지금까지 발견한 가장 큰 차이를 기억합니다.

<h3>알고리즘 2</h3>

```py
def max_diff(numbers):
    numbers = sorted(numbers)
    return numbers[-1] - numbers[0]
```
두 번째 알고리즘의 아이디어는 가장 큰 차이는 리스트에서 가장 작은 숫자와 가장 큰 숫자 사이에 있어야 한다는 것입니다.
이 알고리즘은 먼저 `sorted` 함수를 사용하여 리스트를 정렬합니다. 그러면 가장 작은 숫자는 리스트의 처음 (인덱스 0)에 있고 가장 큰 숫자는 리스트의 끝 (인덱스 -1)에 있습니다.

<h3>알고리즘 3</h3>
```py
def max_diff(numbers):
    return max(numbers) - min(numbers)
```
세 번째 알고리즘은 가장 작은 숫자와 가장 큰 숫자를 찾는 것에 기반하지만, 정렬 대신 `min`과 `max` 함수를 사용합니다.

<h1>효율성 측정</h1>
알고리즘의 효율성은 주어진 입력에 대해 알고리즘을 실행하고 실행 시간을 측정하는 테스트 프로그램을 통해 연구할 수 있습니다. 주어진 크기의 임의 입력을 생성하도록 테스트 프로그램을 작성하는 것이 종종 좋은 생각입니다. 그러면 다양한 크기의 입력으로 알고리즘을 쉽게 테스트할 수 있습니다.
아래는 <code>max_diff</code> 함수의 효율성을 테스트하는 프로그램입니다.

```py
import random
import time

def max_diff(numbers):
    ...

n = 1000
print("n:", n)
random.seed(1337)
numbers = [random.randint(1, 10**6) for _ in range(n)]
start_time = time.time()
result = max_diff(numbers)
end_time = time.time()
print("result:", result)
print("time:", round(end_time - start_time, 2), "s")
```

변수 <code>n</code>의 값은 테스트에 사용된 리스트의 길이입니다. 함수 <code>random.seed</code>는 난수 생성기의 시드 번호(여기서는 1337)를 설정하여 항상 동일한 난수를 생성하도록 합니다. 이를 통해 테스트 실행 간의 비교가 더 쉽고 신뢰할 수 있습니다. 함수 <code>random.randint</code>와 제너레이터 표현식을 사용하여 1부터 10<sup>6</sup> 사이의 <code>n</code>개의 난수 리스트가 생성됩니다.
프로그램은 <code>time.time</code> 함수를 사용하여 실행 시간을 측정합니다. 이 함수는 1970년 초부터 경과된 시간을 초 단위로 반환합니다. 알고리즘 실행 전후의 시간 차이는 실행에 걸린 시간을 나타냅니다. 시간은 <code>round</code> 함수를 사용하여 소수점 두 자리로 반올림됩니다.
테스트 프로그램의 실행 결과는 다음과 유사하게 출력됩니다.

```
n: 1000
result: 999266
time: 0.09 s
```
이는 알고리즘의 입력이 길이가 1000인 리스트였고, 알고리즘의 출력이 999266이었으며, 알고리즘 실행에 0.09초가 걸렸음을 의미합니다.
다음 표는 테스트 컴퓨터에서 다양한 크기의 입력에 대한 위 세 가지 알고리즘의 실행 시간을 보여줍니다.
<table>
    <thead>
        <tr>
            <th>리스트 길이 n</th>
            <th>알고리즘 1</th>
            <th>알고리즘 2</th>
            <th>알고리즘 3</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>1000</td>
            <td>0.17 s</td>
            <td>0.00 s</td>
            <td>0.00 s</td>
        </tr>
        <tr>
            <td>10000</td>
            <td>15.93 s</td>
            <td>0.00 s</td>
            <td>0.00 s</td>
        </tr>
        <tr>
            <td>100000</td>
            <td>–</td>
            <td>0.01 s</td>
            <td>0.00 s</td>
        </tr>
        <tr>
            <td>1000000</td>
            <td>–</td>
            <td>0.27 s</td>
            <td>0.02 s</td>
        </tr>
    </tbody>
</table>
이 표는 알고리즘의 효율성에 큰 차이가 있음을 보여줍니다. 알고리즘 1은 큰 입력에 대해 느리고, 가장 큰 두 입력에 대한 테스트는 실행 시간이 너무 오래 걸려 중단되었습니다. 반면에 알고리즘 2와 3은 큰 입력에 대해서도 효율적입니다. 가장 큰 입력은 알고리즘 2와 3 사이의 차이도 보여주지만, 그 차이는 알고리즘 1에 비해 크지 않습니다.

<h2>알고리즘 분석</h2>
알고리즘의 효율성은 주어진 크기의 입력에 대해 알고리즘이 실행하는 단계 수를 세어 추정할 수 있습니다. 종종 단계를 코드 한 줄에 해당하는 것으로 생각할 수 있습니다.
리스트에서 짝수의 개수를 세는 예제 알고리즘을 고려해 봅시다.

```py
def count_even(numbers):
    result = 0
    for x in numbers:
        if x % 2 == 0:
            result += 1
    return result
```
$n$을 리스트의 길이라고 합시다. 알고리즘이 리스트의 모든 요소를 순회하므로 단계 수는 $n$에 따라 달라집니다.
<ul>
    <li>2행과 6행은 루프 외부에 있으므로 한 번만 실행됩니다.</li>
    <li>3행과 4행은 리스트의 각 요소에 대해 한 번씩 실행되므로 $n$번 실행됩니다.</li>
    <li>5행은 리스트에 있는 짝수의 개수에 따라 최소 0번에서 최대 $n$번 실행됩니다.</li>
</ul>
따라서 알고리즘은 최소 $2n + 2$단계에서 최대 $3n + 2$단계를 실행합니다. 정확한 단계 수는 리스트의 내용에 따라 달라집니다.

<h3>시간 복잡도</h3>
종종 정확한 단계 수를 결정할 필요는 없지만, 주어진 입력 크기에 대한 단계 수의 크기를 나타내는 <b>시간 복잡도</b>를 아는 것으로 충분합니다.
시간 복잡도는 일반적으로 $O(\cdots)$ 형태로 표시되며, 세 개의 점은 단계 수의 상한을 나타내는 산술 표현식으로 대체됩니다. 이 표현식에는 입력 크기를 나타내는 변수 $n$이 포함됩니다. 예를 들어 입력이 리스트인 경우 $n$은 리스트의 길이이고, 입력이 문자열인 경우 $n$은 문자열의 길이입니다.
시간 복잡도 표현식은 일반적으로 정확한 단계 수에 대한 표현식에서 가장 빠르게 증가하는 항만 유지하고 모든 상수를 제거하여 얻은 단순화된 형태입니다. 예를 들어 앞선 알고리즘의 시간 복잡도는 정확한 단계 수가 최대 $3n + 2$이므로 $O(n)$입니다.
형식적으로 알고리즘의 시간 복잡도는 $n \ge n_0$일 때 알고리즘이 최대 $cf(n)$ 단계를 실행하도록 두 상수 $c$와 $n_0$을 선택할 수 있다면 $O(f(n))$입니다. 예를 들어 앞선 알고리즘의 시간 복잡도는 $c=5$와 $n_0=1$을 선택할 수 있으므로 $O(n)$입니다. $n \ge 1$일 때 $3n + 2 \le 5n$이므로 이는 유효한 선택입니다.
일반적인 시간 복잡도는 다음과 같습니다.

<table>
    <thead>
        <tr>
            <th>시간 복잡도</th>
            <th>복잡도 종류 이름</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$O(1)$</td>
            <td>상수 시간</td>
        </tr>
        <tr>
            <td>$O(\log n)$</td>
            <td>로그 시간</td>
        </tr>
        <tr>
            <td>$O(n)$</td>
            <td>선형 시간</td>
        </tr>
        <tr>
            <td>$O(n \log n)$</td>
            <td>–</td>
        </tr>
        <tr>
            <td>$O(n^2)$</td>
            <td>이차 시간</td>
        </tr>
        <tr>
            <td>$O(n^3)$</td>
            <td>삼차 시간</td>
        </tr>
    </tbody>
</table>

<h3>루프의 시간 복잡도</h3>
실제로 시간 복잡도는 종종 코드의 루프에 의해 결정됩니다.

<h4>상수 시간</h4>
알고리즘에 루프가 없고 입력에 관계없이 동일한 단계를 실행하면 시간 복잡도는 $O(1)$입니다.
예를 들어 다음 알고리즘의 시간 복잡도는 $O(1)$입니다.

```py
def middle(numbers):
    n = len(numbers)
    return numbers[n // 2]
```

<h4>단일 루프</h4>
알고리즘에 입력의 모든 요소를 순회하는 단일 루프가 포함되어 있으면 시간 복잡도는 $O(n)$입니다.
예를 들어 다음 알고리즘의 시간 복잡도는 $O(n)$입니다.

```py
def calc_sum(numbers):
    result = 0
    for x in numbers:
        result += x
    return result
```
알고리즘에 리스트의 요소를 순회하는 단일 루프가 있으므로 시간 복잡도는 $O(n)$입니다.

<h4>중첩 루프</h4>
알고리즘에 루프 안에 루프가 있고 각 루프가 입력의 모든 요소를 순회하면 시간 복잡도는 $O(n^2)$입니다.
예를 들어 다음 알고리즘의 시간 복잡도는 $O(n^2)$입니다.

```py
def has_sum(numbers, x):
    for a in numbers:
        for b in numbers:
            if a + b == x:
                return True
    return False
```
일반적으로 알고리즘에 각각 입력의 모든 요소를 순회하는 $k$개의 중첩 루프가 있으면 시간 복잡도는 $O(n^k)$입니다.

<h4>순차적 코드 세그먼트</h4>
알고리즘이 순차적으로 여러 코드 세그먼트로 구성되어 있으면 전체 시간 복잡도는 세그먼트 시간 복잡도의 최댓값입니다.
예를 들어 다음 알고리즘의 시간 복잡도는 $O(n)$입니다.

```py
def count_min(numbers):
    # 단계 1
    min_value = numbers[0]
    for x in numbers:
        if x < min_value:
            min_value = x

    # 단계 2
    result = 0
    for x in numbers:
        if x == min_value:
            result += 1

    return result
```

단계 1에서 알고리즘은 모든 요소를 순회하여 리스트에서 최소값을 찾습니다. 단계 1의 시간 복잡도는 $O(n)$입니다.
단계 2에서 알고리즘은 최소값의 발생 횟수를 세기 위해 요소를 다시 순회합니다. 단계 2의 시간 복잡도는 $O(n)$입니다.
각 단계의 시간 복잡도가 $O(n)$이므로 전체 알고리즘의 시간 복잡도는 $O(n)$입니다.