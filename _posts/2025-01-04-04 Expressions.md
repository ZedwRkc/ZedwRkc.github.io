---
title: 4장 표현식
date: 2025-01-04
categories: [C]
tags: [C]
math: true
---
C 언어의 두드러진 특징 중 하나는 **문장(statements)**보다는 표현식(expressions)—값을 계산하는 공식을 보여주는 형식—에 중점을 둔다는 점이다. 가장 단순한 표현식은 변수와 상수이다. 변수는 프로그램이 실행되는 동안 계산될 값을 나타내고, 상수는 변하지 않는 값을 나타낸다. 더 복잡한 표현식은 피연산자(역시 표현식인 경우가 많다)에 연산자를 적용한다.
예를 들어, a + (b * c)라는 표현식에서 + 연산자는 피연산자인 a와 (b * c)에 적용되며, 이들 모두는 그 자체로 표현식이다.

## _**4.1 산술 연산자**_
산술 연산자—덧셈, 뺄셈, 곱셈, 나눗셈을 수행하는 연산자—는 C를 포함한 많은 프로그래밍 언어에서 핵심 도구이다. 아래의 표 4.1은 C 언어의 산술 연산자를 보여준다.
연산자는 표현식을 구성하는 기본 도구이며, C는 이 연산자들을 아주 풍부하게 제공한다. 우선, C는 대부분의 프로그래밍 언어에서 제공하는 기본적인 연산자들을 포함하고 있다:

덧셈, 뺄셈, 곱셈, 나눗셈 등의 산술 연산자

“i는 0보다 크다”와 같은 비교를 수행하는 관계 연산자

“i는 0보다 크고 10보다 작다”와 같은 조건을 구성하는 논리 연산자

그러나 C는 여기서 멈추지 않는다. 이외에도 수십 가지의 다른 연산자들을 제공한다. 실제로 연산자의 수가 너무 많아서, 이 책의 처음 20개 장을 거치면서 점차적으로 소개해야 할 정도다.
이 많은 연산자를 마스터하는 것은 번거롭지만, C 언어에 능숙해지기 위해 필수적이다.

이 장에서는 C의 가장 기본적인 연산자들을 다룰 것이다:
산술 연산자(4.1절), 대입 연산자(4.2절), 증가/감소 연산자(4.3절).
4.1절에서는 또한 연산자 우선순위와 결합 방향도 설명하는데, 이는 여러 연산자가 포함된 표현식을 이해하는 데 중요하다.
4.4절에서는 C 표현식이 어떻게 계산되는지 설명하며,
마지막으로 4.5절에서는 **표현식 문(expression statement)**이라는 독특한 기능을 소개한다. 이 기능은 어떤 표현식도 문으로 사용될 수 있게 한다.

표 4.1 산술 연산자

단항(Unary)	이항(Binary)
덧셈 관련(Additive)	+ 덧셈(Addition)
+ 단항 플러스	- 뺄셈(Subtraction)
- 단항 마이너스	곱셈 관련(Multiplicative)
* 곱셈(Multiplication)
/ 나눗셈(Division)
% 나머지(Remainder)

덧셈 및 곱셈 연산자는 두 개의 피연산자가 필요하기 때문에 이항 연산자라고 한다. 반면 단항 연산자는 하나의 피연산자만 필요하다:

c
코드 복사
i = +1;
j = -i;  /* +는 단항 연산자로 사용됨 */
/* -도 단항 연산자로 사용됨 */
단항 + 연산자는 아무 효과도 없다. 실제로 K&R C에는 이 연산자가 존재하지도 않았다. 이 연산자는 주로 숫자 상수가 양수임을 강조하기 위해 사용된다.

이항 연산자들은 아마 익숙할 것이다. 다만 %(나머지) 연산자는 익숙하지 않을 수 있다.
i % j의 값은 i를 j로 나눈 나머지이다.
예: 10 % 3의 값은 1, 12 % 4의 값은 0.

표 4.1에 있는 이항 연산자들—%를 제외하고—는 정수형 혹은 부동소수형 피연산자를 허용하며, 이 둘을 혼합해서 사용해도 된다.
정수형(int)과 부동소수형(float)을 혼합해서 사용하면 결과값은 float 타입이 된다.
예: 9 + 2.5f의 값은 11.5, 6.7f / 2의 값은 3.35.

하지만 /와 % 연산자는 주의가 필요하다:

/ 연산자는 놀라운 결과를 낼 수 있다. 두 피연산자가 모두 정수일 경우, 결과의 소수점 이하 부분은 버려진다(절삭됨).
예: 1 / 2의 값은 0이다. (0.5가 아님)

% 연산자는 정수형 피연산자만을 요구한다. 둘 중 하나라도 정수가 아니면, 프로그램은 컴파일되지 않는다.

/ 또는 %의 오른쪽 피연산자가 0인 경우, **정의되지 않은 동작(undefined behavior)**이 발생한다.

/와 %가 음수 피연산자와 함께 사용될 때 결과를 설명하는 것은 복잡하다.
C89 표준에 따르면, 피연산자 중 하나가 음수일 경우, 나눗셈 결과는 내림 혹은 올림이 될 수 있다.
예: -9 / 7은 -1 또는 -2가 될 수 있다.
i 또는 j가 음수일 경우, i % j의 부호는 구현에 따라 다르다.
예: -9 % 7은 -2 또는 5가 될 수 있다.

C99에서는 다르게 정의된다: 나눗셈 결과는 항상 0 방향으로 절삭되며, %의 결과는 항상 왼쪽 피연산자의 부호를 따른다.
예: -9 / 7은 -1, -9 % 7은 -2가 된다.

구현 정의된 동작 (Implementation-Defined Behavior)

앞으로 자주 등장할 용어가 있으므로, 지금 설명해두는 것이 좋다.
C 표준은 언어의 일부 동작을 의도적으로 명확히 정의하지 않고 “구현”에 맡긴다—즉, 특정 플랫폼에서 프로그램을 컴파일, 링크, 실행하기 위한 소프트웨어가 세부 사항을 정의하게 한다.
이로 인해 프로그램의 동작이 구현(컴파일러, 시스템 등)에 따라 달라질 수 있다.
C89에서 /, % 연산자의 음수 피연산자 처리 방식이 그 예이다.

이렇게 언어의 일부를 명확히 정의하지 않는 것은 이상하거나 위험해 보일 수 있지만, C 언어의 철학을 반영하는 것이다.
C 언어는 효율성을 중시하며, 이는 종종 하드웨어의 동작 방식에 맞춰야 한다는 뜻이다.
어떤 CPU는 -9 / 7을 -1로, 다른 CPU는 -2로 결과를 반환한다. C89 표준은 이 차이를 그대로 수용한 것이다.

구현 정의된 동작에 의존하는 프로그램을 작성하지 않는 것이 가장 좋다.
피할 수 없다면, 문서를 주의 깊게 확인하자. C 표준은 구현 정의 동작이 문서화되어야 한다고 요구한다.

연산자 우선순위와 결합 방향

표현식에 여러 연산자가 포함되었을 때, 그 해석이 명확하지 않을 수 있다.
예: i + j * k는 “i와 j를 더한 후 그 결과에 k를 곱하라”는 의미일까, 아니면 “j와 k를 먼저 곱하고 그 결과에 i를 더하라”는 의미일까?
이 문제의 한 가지 해결책은 괄호를 사용하는 것이다: (i + j) * k 또는 i + (j * k)처럼.
일반적으로 C는 모든 표현식에서 괄호 사용을 허용한다.

하지만 괄호를 사용하지 않으면 어떻게 해석될까?
컴파일러는 i + j * k를 (i + j) * k로 해석할까, i + (j * k)로 해석할까?
많은 언어와 마찬가지로, C는 연산자 우선순위 규칙을 사용하여 이러한 모호함을 해결한다.
산술 연산자의 우선순위는 다음과 같다:

markdown
코드 복사
우선순위가 높은 순:
+ - (단항)
* / %
+ - (이항)
같은 줄에 있는 연산자는 동일한 우선순위를 가진다.
여러 연산자가 포함된 표현식의 해석은 다음과 같이 우선순위가 높은 연산자부터 괄호로 묶는 방식으로 생각할 수 있다:

i + j * k → i + (j * k)

-i * -j → (-i) * (-j)

+i + j / k → (+i) + (j / k)

하지만 우선순위만으로는 충분하지 않다. 같은 우선순위를 가진 연산자가 둘 이상 있을 경우, **결합 방향(associativity)**이 적용된다.
연산자가 **왼쪽 결합(left associative)**이면 왼쪽에서 오른쪽으로 그룹화한다.
산술 이항 연산자(*, /, %, +, -)는 모두 왼쪽 결합이므로:

i - j - k → (i - j) - k

i * j / k → (i * j) / k

반면 연산자가 **오른쪽 결합(right associative)**이면 오른쪽에서 왼쪽으로 그룹화한다.
단항 연산자(+, -)는 오른쪽 결합이므로:

- + i → -(+i)

우선순위와 결합 방향은 대부분의 언어에서 중요하지만, 특히 C에서는 매우 중요하다.
하지만 C에는 거의 50개의 연산자가 있어서 대부분의 프로그래머는 모든 규칙을 외우지 않고, 필요한 경우 연산자 우선순위 표를 참조하거나 괄호를 충분히 사용하는 편이다.

프로그램: UPC 체크 숫자 계산

수년 동안, 미국과 캐나다에서 판매되는 상품에는 바코드가 부착되어 왔다.
이 바코드는 **UPC(Universal Product Code)**로 알려져 있으며, 제조사와 제품을 식별한다.
각 바코드는 12자리 숫자를 나타내며, 바코드 아래에 인쇄된다.

예를 들어, Stouffer's French Bread Pepperoni Pizza의 바코드는 다음과 같다:

숫자: 0 13800 15173 5

첫 번째 숫자: 제품 유형을 식별 (일반적으로 0 또는 7, 무게 상품은 2, 약품은 3, 쿠폰은 5)

첫 번째 5자리: 제조사 코드 (13800은 Nestlé USA의 Frozen Food Division)

두 번째 5자리: 제품 코드

마지막 숫자: 체크 숫자 — 앞의 숫자들에 오류가 있을 경우를 감지하는 데 사용됨

체크 숫자를 계산하는 방법:

1, 3, 5, 7, 9, 11번째 자릿수를 더함

2, 4, 6, 8, 10번째 자릿수를 더함

첫 번째 합계를 3배하고, 두 번째 합을 더함

전체에서 1을 뺌

10으로 나눈 나머지를 구함

9에서 그 나머지를 뺌

Stouffer's 예시:

첫 번째 합: 0 + 3 + 0 + 1 + 1 + 3 = 8

두 번째 합: 1 + 8 + 0 + 5 + 7 = 21

전체 합: 3 * 8 + 21 = 45

1 빼기: 44

10으로 나눈 나머지: 4

9에서 나머지 뺌: 9 - 4 = 5

다른 예:

Jif 크리미 땅콩버터 (18 oz): 0 51500 24128 ? → 체크 숫자: 8

Ocean Spray 젤리 크랜베리 소스 (8 oz): 0 31200 01005 ? → 체크 숫자: 6

프로그램 코드

c
코드 복사
/* UPC 체크 숫자 계산 */
#include <stdio.h>

int main(void)
{
    int d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5;
    int first_sum, second_sum, total;

    printf("Enter the first (single) digit: ");
    scanf("%1d", &d);

    printf("Enter first group of five digits: ");
    scanf("%1d%1d%1d%1d%1d", &i1, &i2, &i3, &i4, &i5);

    printf("Enter second group of five digits: ");
    scanf("%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &j5);

    first_sum = d + i2 + i4 + j1 + j3 + j5;
    second_sum = i1 + i3 + i5 + j2 + j4;
    total = 3 * first_sum + second_sum;

    printf("Check digit: %d\n", 9 - ((total - 1) % 10));

    return 0;
}
9 - ((total - 1) % 10)라는 표현식은 9 - (total - 1) % 10처럼 작성할 수도 있었지만, 괄호를 하나 더 추가하면 의미를 이해하기가 더 쉬워진다.


## _**4.2 대입 연산자**_
표현식의 값이 계산된 후에는 종종 그 값을 나중에 사용하기 위해 변수에 저장해야 한다. C의 = (단순 대입) 연산자는 이러한 목적에 사용된다. 변수에 이미 저장된 값을 갱신하기 위해, C는 다양한 복합 대입 연산자를 제공한다.

단순 대입
대입 v = e의 효과는 표현식 e를 평가하고 그 값을 v에 복사하는 것이다. 다음 예제들에서 보이듯, e는 상수, 변수 또는 더 복잡한 표현식이 될 수 있다:

c
코드 복사
i = 5;  
j = i;  
k = 10 * i + j;  /* i는 이제 5 */  
               /* j도 이제 5 */  
               /* k는 이제 55 */
v와 e가 동일한 타입이 아니라면, 대입이 이루어지는 동안 e의 값은 v의 타입으로 변환된다:

c
코드 복사
int i;  
float f;  
i = 72.99f;  
f = 136;     /* i는 이제 72 */  
             /* f는 이제 136.0 */
형 변환에 대해서는 나중에 다시 설명할 것이다.
많은 프로그래밍 언어에서는 대입이 문장(statement)이지만, C에서는 대입도 +처럼 하나의 연산자(operator)이다. 즉, 대입 행위 자체도 결과를 생성한다는 의미이다. 숫자 두 개를 더하는 것이 결과를 만들어내는 것처럼, v = e 대입의 값은 대입 후의 v의 값이다. 따라서 i = 72.99f의 값은 72이며, 72.99가 아니다.

부작용 (Side Effects)
보통 연산자는 피연산자를 수정하지 않는다고 기대한다. 수학에서의 연산자는 그렇지 않기 때문이다. 예를 들어 i + j는 단순히 i와 j를 더한 결과를 계산할 뿐 i나 j를 바꾸지 않는다.
C의 대부분의 연산자들도 피연산자를 수정하지 않지만, 몇몇은 그렇지 않다. 이러한 연산자는 단순히 값을 계산하는 것 이상을 수행하므로, 부작용(side effect)이 있다고 말한다.
단순 대입 연산자는 우리가 처음 보는 부작용이 있는 연산자이다. 이는 왼쪽 피연산자를 수정한다. i = 0이라는 표현식을 평가하면 결과값으로 0이 생성되며, 부작용으로 i에 0이 대입된다.

대입은 연산자이기 때문에 여러 대입을 연결해서 작성할 수 있다:

c
코드 복사
i = j = k = 0;
= 연산자는 오른쪽 결합(right associative)이므로 이 대입은 다음과 같다:

c
코드 복사
i = (j = (k = 0));
이렇게 하면 먼저 0이 k에 대입되고, 그 값이 j에 대입되며, 마지막으로 i에 대입된다.
타입 변환으로 인해 연결된 대입에서 예상치 못한 결과가 나올 수도 있다:

c
코드 복사
int i;  
float f;  
f = i = 33.3f;
이 경우 i는 33을, f는 33.0을 갖는다 (당신이 예상할 수 있는 33.3이 아니라).

일반적으로 v = e 형태의 대입은 v 타입의 값이 허용되는 곳이라면 어디서든 사용할 수 있다. 다음 예제를 보자:

c
코드 복사
i = 1;  
k = 1 + (j = i);  
printf("%d %d %d\n", i, j, k);  /* "1 1 2" 출력 */
이와 같이 대입 연산자를 사용하는 방식은 보통 좋은 방법이 아니다. "내부 대입(embedded assignments)"은 프로그램을 읽기 어렵게 만들 수 있고, 섬세한 버그의 원인이 될 수도 있다. 이는 4.4절에서 더 자세히 다룰 것이다.

Lvalue
대부분의 C 연산자는 피연산자로 변수, 상수 또는 다른 연산자를 포함한 표현식을 허용한다. 하지만 대입 연산자는 왼쪽 피연산자로 lvalue가 필요하다.
lvalue(“엘-값”이라 발음)는 컴퓨터 메모리에 저장된 객체를 나타내며, 상수나 계산 결과가 아니다. 변수는 lvalue이다. 10이나 2 * i 같은 표현식은 아니다. 현재까지는 변수만이 우리가 아는 유일한 lvalue이다. 다른 종류의 lvalue는 이후 장에서 다룬다.

대입 연산자는 왼쪽 피연산자로 lvalue만 허용하므로, 다른 종류의 표현식을 대입문 왼쪽에 놓는 것은 불법이다:

c
코드 복사
12 = i;       // *** 잘못된 표현 ***
i + j = 0;    // *** 잘못된 표현 ***
-i = j;       // *** 잘못된 표현 ***
컴파일러는 이러한 오류를 감지하고 “invalid lvalue in assignment” 같은 오류 메시지를 출력한다.

복합 대입
변수의 이전 값을 사용하여 새로운 값을 계산하는 대입은 C 프로그램에서 자주 나타난다. 예를 들어 다음 문장은 i에 저장된 값에 2를 더한다:

c
코드 복사
i = i + 2;
C의 복합 대입 연산자는 이 문장을 더 짧게 쓸 수 있게 해준다. += 연산자를 사용하면 다음과 같다:

c
코드 복사
i += 2;  /* i = i + 2와 동일 */
+= 연산자는 오른쪽 피연산자의 값을 왼쪽 변수에 더한다.
다음과 같은 9개의 복합 대입 연산자가 있다:

ini
코드 복사
-=  *=  /=  %=
(나머지 복합 대입 연산자들은 이후 장에서 다룬다.) 모든 복합 대입 연산자의 동작은 유사하다:

yaml
코드 복사
v += e : v에 e를 더한 결과를 v에 저장  
v -= e : v에서 e를 뺀 결과를 v에 저장  
v *= e : v에 e를 곱한 결과를 v에 저장  
v /= e : v를 e로 나눈 결과를 v에 저장  
v %= e : v를 e로 나눈 나머지를 v에 저장
나는 v += e가 v = v + e와 **“동일하다(equivalent)”**고 표현하지 않았다는 점에 주목하라. 그 이유 중 하나는 연산자 우선순위 때문이다.
예를 들어 i *= j + k는 i = i * j + k와 같지 않다. 또한 v 자체가 부작용을 갖는 경우, 드물게 v += e와 v = v + e가 다르게 작동할 수도 있다. 이 점은 다른 복합 대입 연산자에도 해당된다.

복합 대입 연산자를 사용할 때는 두 문자를 뒤바꾸지 않도록 주의하라. 문자를 뒤바꾸면 컴파일러는 이를 허용하겠지만 의도한 의미와는 달라질 수 있다. 예를 들어 i += j를 쓰려다가 i =+ j라고 잘못 입력하면 프로그램은 컴파일되지만, 이 표현은 단순히 i = (+j)와 같아서 j의 값을 i에 복사하기만 할 뿐이다.


## _**4.3 증감 연산자**_
변수에 대해 가장 일반적인 연산 두 가지는 “증가시키기”(1을 더하기)와 “감소시키기”(1을 빼기)이다. 물론 우리는 다음과 같은 문장을 써서 이러한 작업을 수행할 수 있다:

c
코드 복사
i = i + 1;  
j = j - 1;
복합 대입 연산자를 사용하면 이 문장을 조금 더 간단하게 줄일 수 있다:

c
코드 복사
i += 1;  
j -= 1;
하지만 C에서는 이러한 증가와 감소를 ++ (증가 연산자)와 -- (감소 연산자)를 사용하여 더욱 간단히 줄일 수 있다.

처음 봤을 때는, 증가 및 감소 연산자는 매우 단순해 보인다: ++는 피연산자에 1을 더하고, --는 피연산자에서 1을 뺀다.
하지만 이 단순함은 오해를 불러일으킬 수 있다 — 증가 및 감소 연산자는 사용하기 까다로운 면이 있다. 그 이유 중 하나는 ++와 --가 접두 연산자(prefix operator, 예: ++i, --i)로도, 접미 연산자(postfix operator, 예: i++, i--)로도 사용될 수 있기 때문이다. 프로그램의 정확성은 올바른 버전을 선택하는 것에 달려 있을 수 있다.

또 다른 복잡성은 대입 연산자처럼 ++와 --도 부작용이 있다는 것이다: 이들은 피연산자의 값을 변경한다.

++i 표현식을 평가하면 결과로 i + 1을 생성하며 — 부작용으로 i의 값을 증가시킨다:

c
코드 복사
i = 1;  
printf("i is %d\n", ++i);  
printf("i is %d\n", i);  /* "i is 2" 출력 */  
                        /* "i is 2" 출력 */
i++ 표현식을 평가하면 결과로 i의 기존 값을 생성하고, 그 후에 i가 증가된다:

c
코드 복사
i = 1;  
printf("i is %d\n", i++);  
printf("i is %d\n", i);  /* "i is 1" 출력 */  
                        /* "i is 2" 출력 */
첫 번째 printf는 증가되기 이전의 i 값을 보여주고, 두 번째 printf는 증가된 새로운 i 값을 보여준다.
이 예제에서 보이듯, ++i는 “i를 즉시 증가시켜라”는 의미이고, i++는 “지금은 i의 기존 값을 사용하되, 나중에 증가시켜라”는 의미이다.

“얼마나 나중에?” C 표준은 정확한 시점을 지정하지 않는다. 그러나 i는 다음 문장이 실행되기 전에 증가될 것이라고 가정하는 것이 안전하다.

-- 연산자도 유사한 성질을 갖는다:

c
코드 복사
i = 1;  
printf("i is %d\n", --i);  
printf("i is %d\n", i);  /* "i is 0" 출력 */  
                        /* "i is 0" 출력 */

i = 1;  
printf("i is %d\n", i--);  
printf("i is %d\n", i);  /* "i is 1" 출력 */  
                        /* "i is 0" 출력 */
같은 표현식에서 ++나 --를 두 번 이상 사용하는 경우, 그 결과는 이해하기 어려울 수 있다. 예를 들자:

c
코드 복사
i = 1;  
j = 2;  
k = ++i + j++;
이 문장들이 실행된 후 i, j, k의 값은 어떻게 될까?
i는 그 값이 사용되기 전에 증가되므로, j는 값이 사용된 후에 증가된다.
따라서 마지막 문장은 다음과 같이 동작하는 것과 같다:

c
코드 복사
i = i + 1;  
k = i + j;  
j = j + 1;
최종적으로 i, j, k는 각각 2, 3, 4의 값을 갖는다.
반면 다음 문장을 실행하면:

c
코드 복사
i = 1;  
j = 2;  
k = i++ + j++;
i, j, k는 각각 2, 3, 3의 값을 갖게 된다.

참고로, ++와 --의 접미(postfix) 버전은 단항 플러스와 마이너스보다 우선순위가 높고, 왼쪽 결합성을 가진다.
접두(prefix) 버전은 단항 플러스와 마이너스와 동일한 우선순위를 가지며, 오른쪽 결합성을 가진다.

복합 대입 연산자는 = 연산자와 동일한 특성을 가진다. 특히, 이들은 오른쪽 결합성을 가지므로 다음 문장:

c
코드 복사
i += j += k;
는 다음과 같은 의미이다:

c
코드 복사
i += (j += k);

## _**4.4 표현식의 평가 (Expression Evaluation)**_
표 4.2는 우리가 지금까지 살펴본 연산자들을 요약한 것이다. (부록 A에는 모든 연산자를 보여주는 유사한 표가 있다.) 첫 번째 열은 다른 연산자들과 비교한 각각의 연산자의 **우선순위(precedence)**를 보여준다 (1이 가장 높은 우선순위이고, 5가 가장 낮다). 마지막 열은 각 연산자의 **결합성(associativity)**을 나타낸다.

우선순위	이름	기호	결합성
1	증가 (접미)	++ --	왼쪽
2	증가 (접두), 감소 (접두), 단항 플러스, 단항 마이너스	++ -- + -	오른쪽
3	곱셈, 나눗셈, 나머지	* / %	왼쪽
4	덧셈, 뺄셈	+ -	왼쪽
5	대입	= *= /= %= += -=	오른쪽

표 4.2 (또는 부록 A에 있는 더 큰 표)는 다양한 방식으로 유용하다. 이 중 하나의 예를 살펴보자.

예를 들어, 어떤 사람의 프로그램을 읽고 있다가 다음과 같은 복잡한 표현식을 발견했다고 하자:

c
코드 복사
a = b += c++ - d + --e / -f;
이 표현식은 괄호가 없으면 이해하기 어렵다. 괄호가 있다면 이 표현식이 여러 하위 표현식들로 어떻게 구성되어 있는지 더 쉽게 알 수 있다.
표 4.2의 도움으로, 표현식에 괄호를 추가하는 것은 간단하다:
먼저 표현식을 살펴보면서 가장 높은 우선순위를 가진 연산자를 찾고, 그 연산자와 그 피연산자들에 괄호를 쳐서 그것을 하나의 단위(operand)로 묶는다. 그런 다음 이 과정을 반복하여 표현식 전체를 괄호로 묶는다.

우리 예시에서 가장 우선순위가 높은 연산자는 ++이며, 이는 여기서 접미 연산자로 사용되었으므로 괄호로 묶는다:

c
코드 복사
a = b += (c++) - d + --e / -f;
이제 -- 연산자와 단항 마이너스 연산자 (둘 다 우선순위 2)가 보인다:

c
코드 복사
a = b += (c++) - d + (--e) / (-f);
다른 마이너스 기호는 왼쪽에 피연산자가 있기 때문에 이는 단항 마이너스가 아니라 뺄셈 연산자임을 알 수 있다.

다음으로 / 연산자(우선순위 3)를 찾는다:

c
코드 복사
a = b += (c++) - d + ((--e) / (-f));
이제 우선순위 4인 두 개의 연산자, 즉 뺄셈과 덧셈이 있다.
같은 우선순위를 가진 연산자들이 피연산자에 인접해 있을 때는 결합성에 주의해야 한다. 우리 예시에서는 -와 +가 모두 d에 인접하므로, 결합성 규칙이 적용된다. -와 +는 모두 왼쪽 결합성을 가지므로, 먼저 뺄셈에 괄호를 씌우고, 그 다음 덧셈을 괄호로 감싼다:

c
코드 복사
a = b += (((c++) - d) + ((--e) / (-f)));
남은 연산자는 =과 +=이다. 이 두 연산자는 모두 b에 인접해 있으므로, 여기서도 결합성을 고려해야 한다. 대입 연산자들은 오른쪽 결합성을 가지므로 += 표현식에 괄호를 먼저 씌우고, 그다음에 전체 = 표현식에 괄호를 씌운다:

c
코드 복사
(a = (b += (((c++) - d) + ((--e) / (-f)))));
이제 표현식은 완전히 괄호로 감싸져 있다.

하위 표현식 평가 순서 (Order of Subexpression Evaluation)
연산자 우선순위와 결합성의 규칙은 C 표현식을 하위 표현식으로 분해하는 데 유용하며, 표현식이 완전히 괄호로 감싸졌다면 괄호가 어디에 있어야 하는지를 고유하게 결정할 수 있다.

그러나 아이러니하게도, 이러한 규칙들은 표현식의 값을 항상 결정해 주지는 않는다. 왜냐하면 표현식을 구성하는 하위 표현식들이 평가되는 순서에 따라 값이 달라질 수 있기 때문이다.

C는 (논리 AND, 논리 OR, 조건 연산자, 콤마 연산자를 포함한 일부 경우를 제외하고는) 하위 표현식의 평가 순서를 정의하지 않는다.
예를 들어 다음 표현식에서:

c
코드 복사
(a + b) * (c - d)
(a + b)가 먼저 평가되는지, (c - d)가 먼저 평가되는지 우리는 알 수 없다.

대부분의 표현식은 하위 표현식의 평가 순서에 상관없이 동일한 값을 갖는다.
하지만, 어떤 하위 표현식이 그 피연산자를 수정하는 경우, 이 말은 성립하지 않는다. 예를 들어 다음 코드를 보자:

c
코드 복사
a = 5;  
c = (b = a + 2) - (a = 1);
이 문장을 실행했을 때의 효과는 정의되어 있지 않다(Undefined Behavior). C 표준은 어떤 일이 일어날지를 명확히 규정하지 않는다.
대부분의 컴파일러에서, c의 값은 6 또는 2 중 하나가 될 것이다.

(b = a + 2)가 먼저 평가되면, b는 7이 되고, c는 6이 된다.

(a = 1)이 먼저 평가되면, b는 3이 되고, c는 2가 된다.

이와 같이, 표현식 내부에서 변수를 참조하고, 동시에 그 값을 수정하는 것은 피해야 한다. 위 표현식은 a의 값을 참조하여 a + 2를 계산하고, 동시에 a의 값을 1로 변경하고 있다.
일부 컴파일러는 이와 같은 표현식을 만나면 다음과 같은 경고 메시지를 낼 수 있다:

“operation on ‘a’ may be undefined” (변수 ‘a’에 대한 연산이 정의되지 않을 수 있음)

이러한 문제를 방지하려면, 대입 연산자를 하위 표현식에서 사용하지 말고 다음과 같이 여러 개의 별도 대입문으로 나누는 것이 좋다:

c
코드 복사
a = 5;  
b = a + 2;  
a = 1;  
c = b - a;
이 경우에는 항상 c의 값이 6이 된다.

대입 연산자 외에, 피연산자를 변경하는 연산자는 증가(++)와 감소(--) 뿐이다.
이 연산자들을 사용할 때도 표현식이 특정한 평가 순서에 의존하지 않도록 주의해야 한다. 다음 예제를 보자:

c
코드 복사
i = 2;  
j = i * i++;
많은 사람들은 j가 4가 될 것이라고 생각할 수 있다. 그러나 이 문장을 실행했을 때의 효과는 정의되어 있지 않다(Undefined Behavior). j는 6이 될 수도 있다.

어떤 상황일 수 있는지를 설명하면 이렇다:

두 번째 피연산자(i의 원래 값)가 먼저 읽혀지고, i는 증가된다.

첫 번째 피연산자(i의 새 값)가 읽혀진다.

새 값과 원래 값이 곱해져서 6이 된다.

“변수를 읽는다(fetch)”는 것은 변수의 값을 메모리에서 가져온다는 뜻이다. 이후에 그 변수의 값이 변경되더라도, 이미 가져온 값은 보통 CPU 내부의 **레지스터(register)**라고 불리는 특별한 위치에 저장되므로 영향을 받지 않는다.

정의되지 않은 동작 (Undefined Behavior)
C 표준에 따르면, 다음과 같은 문장들:

c
코드 복사
c = (b = a + 2) - (a = 1);  
j = i * i++;
은 **정의되지 않은 동작(undefined behavior)**을 유발한다. 이는 **구현 정의 동작(implementation-defined behavior)**과는 다르다 (4.1절 참조).

프로그램이 정의되지 않은 동작의 영역으로 들어가면, 무슨 일이든 일어날 수 있다.

컴파일러마다 동작이 다를 수 있고,

프로그램이 컴파일되지 않을 수도 있고,

실행되지 않을 수도 있고,

실행된다 해도 충돌(crash)하거나, 이상하게 동작하거나, 말도 안 되는 결과를 낼 수 있다.

즉, 정의되지 않은 동작은 전염병처럼 피해야 한다.


## _**4.5 표현식 문장 (Expression Statements)**_
C에는 모든 표현식을 문장으로 사용할 수 있다는 특이한 규칙이 있다. 즉, 표현식이 어떤 타입이든, 또는 무엇을 계산하든 상관없이, 세미콜론(;)을 붙이면 문장이 된다.
예를 들어, ++i라는 표현식을 다음과 같이 문장으로 바꿀 수 있다:

c
코드 복사
++i;
이 문장이 실행되면, i는 먼저 증가되고, 그 다음 i의 새 값이 불러들여진다 (마치 그것이 감싸고 있는 표현식에서 사용될 것처럼).
하지만 ++i가 더 큰 표현식의 일부가 아니기 때문에, 이 값은 폐기되고 다음 문장이 실행된다. (물론 i에 대한 변경은 영구적이다.)

값이 폐기되기 때문에, 표현식을 문장으로 사용하는 유일한 의미는 그 표현식이 **부작용(side effect)**을 가질 때뿐이다. 세 가지 예를 살펴보자.

첫 번째 예제에서, 1이 i에 저장되고, i의 새 값이 불러들여지지만 사용되지 않는다:

c
코드 복사
i = 1;
두 번째 예제에서는, i의 값이 불러들여지지만 사용되지 않고, 그 후 i는 감소된다:

c
코드 복사
i--;
세 번째 예제에서는, 표현식 i * j - 1의 값이 계산된 후 폐기된다:

c
코드 복사
i * j - 1;
이 경우 i와 j는 변경되지 않기 때문에 이 문장은 아무런 효과가 없고, 따라서 아무런 목적도 없다.

키보드 실수로 인해 쉽게 “아무것도 하지 않는” 표현식 문장을 만들 수 있다. 예를 들어:

c
코드 복사
i = j;
를 입력하려다가 실수로 다음처럼 입력할 수 있다:

c
코드 복사
i + j;
(이러한 실수는 예상보다 흔한데, =와 + 키가 일반적으로 같은 키 위에 있기 때문이다.)
일부 컴파일러는 의미 없는 표현식 문장을 감지할 수 있으며, “statement with no effect”와 같은 경고 메시지를 출력할 것이다.

## _**Q & A**_

Q: C에는 거듭제곱(exponentiation) 연산자가 없는 것 같은데, 어떻게 수를 제곱할 수 있나요?
A: 정수를 작고 양의 정수로 거듭제곱하는 가장 좋은 방법은 곱셈을 반복하는 것입니다 (i * i * i는 i의 세제곱).
정수를 실수 지수로 제곱하고 싶다면, pow 함수를 사용하세요.

Q: % 연산자를 부동소수점(floating-point) 피연산자에 사용하고 싶은데, 프로그램이 컴파일되지 않습니다. 어떻게 해야 하나요? [p. 54]
A: % 연산자는 정수 피연산자만을 요구합니다. 대신 fmod 함수를 사용하세요.

Q: 음수 피연산자와 함께 / 및 % 연산자를 사용할 때 규칙이 왜 이렇게 복잡한가요? [p. 54]
A: 규칙은 처음에는 복잡해 보이지만, 실제로는 그렇지 않습니다. C89와 C99에서는
(a / b) * b + a % b의 결과가 항상 a가 되도록 하는 것이 목적입니다 (실제로 이 두 표준은 a / b의 결과가 "표현 가능한 값"인 한 이 식의 결과가 a가 됨을 보장합니다).

문제는 a 또는 b가 음수일 경우, 이 등식 (a / b) * b + a % b == a를 만족시키는 방법이 두 가지가 있다는 것입니다.
예를 들어 C89에서는 -9 / 7이 –1이고 -9 % 7이 –2일 수도 있고,
또는 -9 / 7이 –2이고 -9 % 7이 5일 수도 있습니다.

첫 번째 경우: (-9 / 7) * 7 + (-9 % 7) → –1 × 7 + (–2) = –9

두 번째 경우: –2 × 7 + 5 = –14 + 5 = –9

C99가 등장했을 때, 대부분의 CPU는 나눗셈 결과를 **0 방향으로 절삭(truncate)**하도록 설계되어 있었고, 이 결과를 표준에 유일한 허용 결과로 명시했습니다.

Q: C에 lvalue가 있다면, rvalue도 있나요? [p. 59]
A: 네, 물론 있습니다.
lvalue는 대입문의 왼쪽에 올 수 있는 표현식이고,
rvalue는 대입문의 오른쪽에 올 수 있는 표현식입니다.
따라서 rvalue는 변수, 상수, 또는 더 복잡한 표현식일 수 있습니다.
이 책에서는 (그리고 C 표준에서도) rvalue라는 용어 대신 보통 “expression”이라는 단어를 사용합니다.

Q: v += e는 v = v + e와 동일하지 않다고 했는데, 특히 v에 부작용이 있을 때 그렇다고 했습니다. 설명해 주시겠어요? [p. 60]
A: v += e를 평가할 때 v는 한 번만 평가됩니다.
하지만 v = v + e에서는 v가 두 번 평가됩니다.
따라서 v를 평가할 때 발생하는 부작용이 있다면, 후자의 경우 그것이 두 번 발생합니다.

예를 들어 다음 문장에서, i는 한 번 증가됩니다:

c
코드 복사
a[i++] += 2;
하지만 += 대신 =을 사용하면 다음과 같아집니다:

c
코드 복사
a[i++] = a[i++] + 2;
여기에서는 i의 값이 변경됨과 동시에 문장의 다른 부분에서 사용되므로, 이 문장을 실행한 결과는 정의되지 않습니다.
i가 두 번 증가될 가능성이 높지만, 정확히 어떤 일이 일어날지는 확실히 말할 수 없습니다.

Q: C는 왜 ++와 -- 연산자를 제공하나요?
단순히 편의성 때문인가요, 아니면 다른 방식보다 빠르기 때문인가요? [p. 61]
A: C는 Ken Thompson이 만든 초기 B 언어로부터 ++와 -- 연산자를 물려받았습니다.
Thompson은 자신의 B 컴파일러가 i = i + 1보다 ++i에 대해 더 간결한 번역 결과를 생성할 수 있었기 때문에, 이러한 연산자를 만든 것으로 보입니다.

이 연산자들은 이제 C 언어에 깊숙이 자리 잡았고 (사실 C의 가장 유명한 관용구 중 다수가 이 연산자에 의존합니다),
현대 컴파일러에서는 ++나 --를 쓴다고 해서 프로그램이 더 작거나 빨라지지는 않습니다.
이 연산자들의 지속적인 인기는 주로 간결함과 편리성 때문입니다.

Q: ++와 -- 연산자는 float 변수에도 작동하나요?
A: 네, 증가 및 감소 연산자는 정수뿐만 아니라 부동소수점 수에도 적용할 수 있습니다.
하지만 실무에서는 float 변수를 증가시키거나 감소시키는 경우는 그다지 흔하지 않습니다.

Q: 접미(postfix) 버전의 ++나 --를 사용할 때, 증가나 감소는 정확히 언제 수행되나요? [p. 62]
A: 아주 좋은 질문입니다. 안타깝게도 대답하기 어려운 질문이기도 합니다.
C 표준은 “시퀀스 포인트(sequence point)”라는 개념을 도입하며,

“피연산자의 저장된 값을 갱신하는 작업은 이전 시퀀스 포인트와 다음 시퀀스 포인트 사이에 발생해야 한다”고 말합니다.

C에는 다양한 종류의 시퀀스 포인트가 있습니다.
예를 들어, 표현식 문장의 끝이 시퀀스 포인트입니다.
표현식 문장이 끝나기까지, 그 문장 안의 모든 증가/감소 연산은 반드시 완료되어야 하며,
다음 문장이 실행되기 전에 완료되어야 합니다.

앞으로 배울 연산자들(논리 AND, 논리 OR, 조건 연산자, 콤마 연산자 등)도 시퀀스 포인트를 강제합니다.
함수 호출도 마찬가지입니다 — 함수 호출 시, **모든 인자(argument)**는 호출되기 전에 완전히 평가되어야 합니다.
만약 인자 중에 ++ 또는 -- 연산자가 포함된 표현식이 있다면, 해당 증가/감소 연산은 호출 전에 발생해야 합니다.

Q: “표현식 문장의 값은 폐기된다”는 말은 무슨 뜻인가요? [p. 65]
A: 표현식은 정의상 값을 나타냅니다.
예를 들어 i가 5라면, i + 1을 평가하면 6이라는 값이 생성됩니다.
이 표현식을 문장으로 바꾸기 위해 세미콜론을 붙이면 다음과 같아집니다:

c
코드 복사
i + 1;
이 문장이 실행되면 i + 1의 값은 계산되지만, 우리가 이 값을 저장하거나 사용하지 않았기 때문에, 그 값은 사라집니다.

Q: 하지만 i = 1; 같은 문장은 어떻죠? 여기서 무엇이 폐기된다는 건지 잘 모르겠어요.
A: =는 C에서 하나의 연산자이며, 다른 연산자처럼 값을 생성합니다.

즉,

c
코드 복사
i = 1;
은 i에 1을 대입하고, 전체 표현식의 값은 1입니다.
이 값은 폐기됩니다. 하지만 이 값이 폐기되는 건 아무런 문제가 되지 않아요.
왜냐하면 이 문장을 작성한 목적 자체가 i를 수정하는 것이기 때문이니까요.














