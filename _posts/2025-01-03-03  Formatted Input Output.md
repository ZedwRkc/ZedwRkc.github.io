---
title: 3장 서식화된 입/출력
date: 2025-01-03
categories: [C]
tags: [C]
math: true
---
서식화된 읽기 및 쓰기를 지원하는 scanf와 printf는 C에서 가장 자주 사용되는 함수 중 두 가지다. 이 장에서 보여주듯이, 두 함수 모두 강력하지만 제대로 사용하기 까다롭다.
3.1절에서는 printf를 설명하고, 3.2절에서는 scanf를 다룬다.
어느 절에서도 완전한 세부사항을 제공하지는 않으며, 이는 22장에서 다룰 것이다.

## _**3.1 printf 함수**_
printf 함수는 형식 문자열(format string) 이라 불리는 문자열의 내용을 표시하도록 설계되었으며, 이 문자열에는 출력 중 특정 지점에 값을 삽입할 수도 있다. printf가 호출될 때는 형식 문자열과 함께, 출력 도중 삽입할 값들도 함께 전달되어야 한다:

```c
printf(string, expr1, expr2, …);
```
출력되는 값은 상수, 변수, 더 복잡한 표현식일 수 있다. printf 호출 한 번으로 출력할 수 있는 값의 개수에는 제한이 없다.

형식 문자열에는 일반 문자와 변환 지정자(conversion specification) 둘 다 포함될 수 있는데, 변환 지정자는 % 문자로 시작한다. 변환 지정자는 출력 중 채워질 값의 자리 표시자다. % 문자 뒤에 오는 정보는 해당 값을 내부 형식(이진수)에서 출력 형식(문자)으로 어떻게 변환할 것인지를 지정한다 — 이것이 "변환 지정자"라는 이름의 유래다.

예를 들어, %d는 int 값을 10진수 문자열로 변환하도록 하고, %f는 float 값을 변환하도록 한다.

형식 문자열에 있는 일반 문자는 문자열에 보이는 그대로 출력된다. 변환 지정자는 출력할 값으로 대체된다. 다음 예제를 보자:

```c
int i, j;
float x, y;
i = 10;
j = 20;
x = 43.2892f;
y = 5527.0f;

printf("i = %d, j = %d, x = %f, y = %f\n", i, j, x, y);
```
이 printf 호출은 다음과 같은 출력을 생성한다:

ini
코드 복사
i = 10, j = 20, x = 43.289200, y = 5527.000000
형식 문자열에 있는 일반 문자들은 그대로 출력되고, 네 개의 변환 지정자는 변수 i, j, x, y의 값으로 순서대로 대체된다.

C 컴파일러는 형식 문자열의 변환 지정자 수와 출력 항목 수가 일치하는지 검사할 의무가 없다.
예를 들어, 다음 printf 호출은 출력할 값보다 많은 변환 지정자를 포함한다:

```c
printf("%d %d\n", i);  /*** 잘못됨 ***/
```

이 경우 printf는 i의 값을 정상적으로 출력한 뒤, 두 번째(의미 없는) 정수 값을 출력한다.
반대로, 변환 지정자가 부족할 경우도 문제가 생긴다:

```c
printf("%d\n", i, j);  /*** 잘못됨 ***/
```
이 경우 printf는 i의 값만 출력하고, j의 값은 무시된다.

또한 컴파일러는 변환 지정자가 출력할 항목의 자료형에 적절한지 검사할 필요가 없다. 잘못된 지정자를 사용하면 프로그램은 무의미한 출력을 생성할 뿐이다. 예를 들면:

```c
printf("%f %d\n", i, x);  /*** 잘못됨 ***/
```
이 경우 printf는 float 값을 먼저, 그 다음 int 값을 출력하려 시도한다. 하지만 둘 다 의미 없는 값이 된다.

변환 지정자 (Conversion Specifications)
변환 지정자는 프로그래머가 출력 형식을 매우 정밀하게 제어할 수 있게 해준다. 하지만, 복잡하고 읽기 어려울 수 있다. 변환 지정자를 완전히 설명하는 일은 지금 시점에서는 너무 벅차므로, 여기서는 중요한 기능 일부만 간단히 살펴본다.

2장에서 우리는 변환 지정자에 서식 정보를 포함할 수 있다는 것을 보았다. 예를 들어, %.1f는 float 값을 소수점 이하 한 자리로 출력했다. 더 일반적으로 변환 지정자는 다음과 같은 형식을 가질 수 있다:

perl
코드 복사
%m.pX 또는 %-m.pX
m과 p는 정수 상수

X는 변환 문자 (예: d, f, g 등)

m, p는 선택사항이며, p가 생략되면 .도 생략

예:

%10.2f → m = 10, p = 2, X = f

%10f → m = 10, p 생략

%.2f → p = 2, m 생략

최소 필드 너비(m) 는 출력할 최소 문자 수를 지정한다.
출력값이 m보다 작으면 오른쪽 정렬되고, 왼쪽에 공백이 추가된다.
예: %4d는 숫자 123을 •123으로 출력한다 (•는 공백).
출력값이 m보다 크면 필드 너비는 자동 확장된다.
-를 붙이면 왼쪽 정렬된다. %–4d는 123•로 출력한다.

정밀도(p) 의 의미는 X에 따라 달라진다:

d : 10진수 정수 출력, 최소 p 자리 수 출력 (앞에 0 추가)
(%d는 %.1d와 같음)

e : 지수 형식 출력, p는 소수점 뒤 자릿수 (기본값 6)
p=0이면 소수점 표시 안함

f : 고정 소수점 형식 출력, p는 소수점 뒤 자릿수 (기본값 6)

g : 고정 소수점 또는 지수 형식, 값의 크기에 따라 자동 결정
p는 출력할 유효 숫자 개수 (소수점 뒤가 아님), 뒤따르는 0은 생략

g 지정자는 값의 크기가 예측 불가하거나 크게 변할 수 있는 경우 특히 유용하다.
보통 크기의 숫자는 고정 소수점 형식으로 출력되지만, 매우 크거나 작은 수는 지수 형식으로 출력된다.

%d, %e, %f, %g 외에도 다른 많은 지정자가 있다. 이 책의 뒷부분에서 순차적으로 소개할 것이며, 전체 목록과 세부 설명은 22.3절에서 다룬다.

프로그램: tprintf.c — printf로 숫자 서식 출력
다음 프로그램은 printf를 사용해 정수와 부동 소수점 수를 다양한 형식으로 출력하는 예제이다:

```c
/* Prints int and float values in various formats */
#include <stdio.h>

int main(void)
{
  int i;
  float x;

  i = 40;
  x = 839.21f;

  printf("|%d|%5d|%-5d|%5.3d|\n", i, i, i, i);
  printf("|%10.3f|%10.3e|%-10g|\n", x, x, x);

  return 0;
}
```
printf의 형식 문자열에 들어 있는 | 문자는 출력된 숫자가 차지하는 공간을 보여주기 위한 것이다. %나 \와 달리, |는 printf에게 특별한 의미가 없다.

출력 결과는 다음과 같다:

코드 복사
|40|   40|40   |  040|
|   839.210|  8.392e+02|839.21   |
변환 지정자 분석:

%d : 최소 공간 사용하여 i를 10진수로 출력

%5d : 최소 5문자 공간 확보 → 공백 3칸 + 40

%-5d : 왼쪽 정렬 → 40 뒤에 공백 3칸

%5.3d : 전체 5칸 확보, 최소 3자리 → 앞에 0 하나, 뒤에 공백 2칸 → 040

%10.3f : 고정 소수점 형식, 전체 10칸, 소수점 뒤 3자리
→ 839.210은 7자리 → 앞에 공백 3칸

%10.3e : 지수 형식, 전체 10칸, 소수점 뒤 3자리
→ 9자리 필요 → 앞에 공백 1칸

%-10g : 자동 형식 선택, 전체 10칸, 왼쪽 정렬
→ 고정 소수점 형식으로 선택됨 → 뒤에 공백 4칸

이스케이프 시퀀스 (Escape Sequences)
형식 문자열에서 자주 사용하는 \n 코드는 이스케이프 시퀀스라고 한다.
이스케이프 시퀀스는 문자열 내에 제어 문자나 특수 문자를 포함할 수 있게 해 준다. 다음은 몇 가지 예:

동작	시퀀스
알림음 (벨)	\a
백스페이스	\b
새 줄	\n
수평 탭	\t

이러한 시퀀스는 출력 시 특정 동작을 수행하게 한다:

\a → 대부분의 컴퓨터에서 경고음 출력

\b → 커서를 한 칸 뒤로 이동

\n → 다음 줄로 이동

\t → 탭 정지점으로 이동

문자열에는 여러 개의 이스케이프 시퀀스를 포함할 수 있다. 다음 예제를 보자:

```c
printf("Item\tUnit\tPurchase\n\tPrice\tDate\n");
```
이 문장은 다음과 같은 두 줄짜리 제목을 출력한다:

mathematica
코드 복사
Item    Unit    Purchase
        Price   Date
다른 흔한 이스케이프 시퀀스로는 \"가 있다.
문자열에서 "는 시작과 끝을 나타내기 때문에, 문자열 내부에서 "를 사용하려면 \"로 써야 한다:

```c
printf("\"Hello!\"");
```
이 문장은 다음을 출력한다:

arduino
코드 복사
"Hello!"
참고로, 문자열에 \ 하나만 넣는 것은 불가능하다.
컴파일러는 \를 이스케이프 시퀀스의 시작으로 간주하기 때문이다.
\ 문자 하나를 출력하려면 \\를 써야 한다:

```c
printf("\\");  /* 역슬래시 문자 하나 출력 */
```
나의 말:

## _**3.2 scanf 함수**_
printf가 특정 형식으로 출력을 수행하듯, scanf는 특정 형식에 따라 입력을 읽는다. scanf의 형식 문자열도 printf의 형식 문자열과 마찬가지로 일반 문자와 변환 지정자(conversion specification)를 모두 포함할 수 있다. scanf에서 허용되는 변환은 기본적으로 printf에서 사용되는 것과 동일하다.

많은 경우, scanf의 형식 문자열은 다음 예와 같이 오직 변환 지정자만 포함한다:

```c
int i, j;
float x, y;
scanf("%d%d%f%f", &i, &j, &x, &y);
```
사용자가 다음과 같은 입력을 제공했다고 가정하자:

코드 복사
1 -20 .3 -4.0e3
scanf는 이 입력을 읽고, 그 문자들을 해당 숫자로 변환한 뒤 각각 i, j, x, y에 1, –20, 0.3, –4000.0을 저장하게 된다. " %d%d%f%f "처럼 인접한 변환 지정자를 사용하는 “조밀하게 작성된(tightly packed)” 형식 문자열은 scanf 호출에서 흔히 볼 수 있다. printf의 형식 문자열에서는 인접한 지정자가 덜 일반적이다.

scanf 또한 printf처럼 주의하지 않으면 빠지기 쉬운 함정이 많다. 사용할 때는 변환 지정자 수가 입력 변수 수와 일치하는지, 각 변환이 해당 변수의 형식과 적절하게 일치하는지를 반드시 확인해야 한다. printf와 마찬가지로, 컴파일러는 이러한 불일치를 검사할 의무가 없다.

또 다른 함정은 scanf 호출 시 각 변수 앞에 & 기호를 붙이는 것이다. 이 & 기호는 일반적으로(하지만 항상은 아님) 필수이며, 사용 여부는 전적으로 프로그래머의 책임이다.

scanf 호출 시 변수 앞에 &를 붙이지 않으면 예측 불가능하거나 심각한 결과가 발생할 수 있다. 프로그램이 크래시되는 일도 흔하다. 최소한, 입력에서 읽은 값이 해당 변수에 저장되지 않고, 변수는 이전의 값을 유지하게 되며(초기화되지 않은 경우 의미 없는 값이 될 수 있음), 이는 매우 흔한 실수다 — 반드시 주의할 것!
일부 컴파일러는 이 오류를 감지하여 "format argument is not a pointer" 같은 경고 메시지를 출력하기도 한다. (여기서 “포인터”는 11장에서 설명되며, & 기호는 변수에 대한 포인터를 생성하는 데 사용된다.) 경고가 발생하면, & 누락 여부를 확인하라.

scanf 호출은 강력하지만 관대하지 않은 데이터 읽기 방식이다. 많은 전문 C 프로그래머들은 scanf를 피하고, 대신 모든 데이터를 문자 형태로 읽은 다음 숫자로 변환한다. 그러나 이 책의 초반부에서는 scanf를 자주 사용할 것이며, 이는 숫자를 읽는 간단한 방법을 제공하기 때문이다. 단, 사용자가 예기치 않은 입력을 제공할 경우, 프로그램이 제대로 작동하지 않을 수 있음을 알아두어야 한다.
훗날 살펴보겠지만, scanf가 데이터를 성공적으로 읽었는지를 검사하고 실패 시 복구를 시도하는 것도 가능하다. 하지만 이 책의 예제에서는 너무 많은 코드를 추가해야 하므로 실용적이지 않다.

scanf 작동 방식
scanf는 지금까지 언급한 것보다 훨씬 더 많은 기능을 수행할 수 있다.
본질적으로 scanf는 입력 문자 집합과 형식 문자열을 일치시키려는 "패턴 매칭" 함수다.

printf처럼, scanf도 형식 문자열에 의해 제어된다.
호출되면, scanf는 문자열의 왼쪽부터 정보를 처리하기 시작한다.
형식 문자열의 각 변환 지정자에 대해 scanf는 입력 데이터에서 적절한 형식의 항목을 찾으려 시도하며, 필요하면 공백 문자를 건너뛴다. 이후 항목을 읽고, 그 항목에 속할 수 없는 문자를 만나면 읽기를 중단한다. 항목을 성공적으로 읽었다면, scanf는 형식 문자열의 다음 부분을 계속 처리한다. 어느 항목이라도 읽지 못하면 즉시 반환하며, 남은 형식 문자열이나 입력 데이터를 더 이상 처리하지 않는다.

숫자의 시작을 찾을 때, scanf는 공백 문자(스페이스, 탭, 폼 피드, 줄 바꿈 등) 를 무시한다. 결과적으로 숫자는 한 줄에 있든 여러 줄에 나뉘어 있든 상관없다. 다음 호출을 보자:

```c
scanf("%d%d%f%f", &i, &j, &x, &y);
```
입력이 아래와 같이 세 줄로 주어진 경우:

diff
코드 복사
1
-20 .3
-4.0e3
scanf는 입력을 하나의 연속적인 문자 스트림으로 간주한다:

코드 복사
••1¤-20•••.3¤•••-4.0e3¤
(•는 공백, ¤는 줄 바꿈 문자)

숫자의 시작을 찾기 위해 공백을 건너뛰기 때문에 scanf는 이 숫자들을 모두 성공적으로 읽을 수 있다.
다음 그림에서 s는 건너뛴 문자, r은 항목의 일부로 읽은 문자를 의미한다:

코드 복사
••1¤-20•••.3¤•••-4.0e3¤
ssrsrrrsssrrssssrrrrrr
scanf는 마지막 줄 바꿈 문자를 실제로 읽지 않고 미리 살펴본다(peek). 이 문자는 다음 scanf 호출 시 처음 읽히는 문자가 된다.

정수와 실수를 인식하는 규칙
정수를 읽으려 할 때, scanf는 숫자, + 또는 – 기호를 찾는다. 이후 숫자가 아닌 문자를 만날 때까지 숫자를 읽는다.
실수를 읽으려 할 때, scanf는 다음 형식을 따른다:

선택적인 + 또는 – 기호

소수점을 포함할 수 있는 숫자들의 연속

선택적인 지수 (e 또는 E, 선택적 부호, 하나 이상의 숫자)

%e, %f, %g는 scanf에서 서로 교환 가능하며 같은 규칙을 따른다.

현재 항목의 일부가 될 수 없는 문자를 만나면, 그 문자는 **“반환(push back)”**되어 다음 입력 항목이나 scanf 호출에서 다시 읽힌다.

예를 들어, 아래와 같이 네 개의 숫자가 “비정상적으로” 입력되었다고 하자:

코드 복사
1-20.3-4.0e3¤
동일한 호출:

```c
scanf("%d%d%f%f", &i, &j, &x, &y);
```
이때 scanf는 다음과 같이 작동한다:

%d: 첫 입력 문자는 1 → 정수 시작으로 인식 → 다음 문자는 - → 정수 내부에는 - 불가 → 1을 i에 저장, -는 반환

%d: -20 읽고 다음 문자는 . → 정수는 . 포함 불가 → –20을 j에 저장, .는 반환

%f: .3 읽고 다음은 - → -는 소수점 뒤에서 올 수 없음 → 0.3을 x에 저장, -는 반환

%f: -4.0e3 읽음 → 실수로 인식 가능 → –4.0 × 10^3을 y에 저장, ¤는 반환

마지막 줄 바꿈은 읽히지 않고 다음 호출로 넘겨진다.

형식 문자열 내의 일반 문자
형식 문자열에 일반 문자를 포함하면 패턴 매칭이 한층 강화된다. scanf가 일반 문자를 처리할 때의 동작은 해당 문자가 공백인지 아닌지에 따라 달라진다.

공백 문자: 형식 문자열에 연속된 공백 문자가 있으면, scanf는 입력에서 공백 문자를 모두 건너뛴다.
형식 문자열에 공백이 하나만 있어도, 입력에서는 여러 개의 공백이 일치 가능하다. 심지어 공백이 없어도 일치한다.

기타 문자: 공백이 아닌 문자는 입력의 다음 문자와 정확히 일치해야 한다.
일치하면 입력 문자 폐기 후 계속 처리. 일치하지 않으면 해당 문자를 반환하고 처리를 중단한다.

예를 들어, 형식 문자열이 "%d/%d"인 경우:

입력이 •5/•96일 때:

공백 건너뛰기

%d → 5 읽음

/ 일치 확인 → 맞음 → 폐기

공백 건너뛰기

%d → 96 읽음

입력이 •5•/•96일 때:

%d → 5 읽음

다음 문자 / 확인하려다 공백 만나서 불일치, 스캔 중단

→ 이 경우, 형식 문자열은 "%d /%d"처럼 공백을 포함해야 한다.

printf와 scanf 혼동 주의
scanf와 printf의 호출이 비슷해 보이지만, 중요한 차이가 있다. 이 차이를 무시하면 심각한 오류가 발생할 수 있다.

예를 들어, printf에서 변수 앞에 &를 붙이는 것은 잘못이다:

```c
printf("%d %d\n", &i, &j); /*** 잘못됨 ***/
```
printf는 i와 j의 값이 아닌 주소를 출력하게 되며, 이상한 숫자들이 출력될 것이다.

또한, scanf는 보통 공백을 무시하고 데이터를 찾기 때문에, 형식 문자열에 굳이 일반 문자를 포함할 필요가 없다. printf처럼 문자열을 작성하려다 예상치 못한 동작이 발생할 수 있다:

```c
scanf("%d, %d", &i, &j);
```
이 경우 i는 입력되지만, 다음 입력 문자가 쉼표가 아니면 j는 읽히지 않고 종료된다.

또한 scanf 형식 문자열 끝에 \n을 넣는 것도 좋지 않다.
scanf는 \n을 공백으로 간주하므로, 사용자가 공백 아닌 문자를 입력할 때까지 프로그램이 멈추는 일이 생길 수 있다.

프로그램: 분수 덧셈 (Adding Fractions)
scanf의 패턴 매칭 능력을 활용해 사용자로부터 분수를 읽는 문제를 살펴보자.
분수는 보통 분자/분모 형태로 입력된다. scanf를 사용하면, 분자와 분모를 별도의 정수가 아닌 하나의 입력으로 읽을 수 있다. 다음 프로그램은 두 분수를 더하는 예이다:

```c
/* Adds two fractions */
#include <stdio.h>

int main(void)
{
  int num1, denom1, num2, denom2;
  int result_num, result_denom;

  printf("Enter first fraction: ");
  scanf("%d/%d", &num1, &denom1);

  printf("Enter second fraction: ");
  scanf("%d/%d", &num2, &denom2);

  result_num = num1 * denom2 + num2 * denom1;
  result_denom = denom1 * denom2;

  printf("The sum is %d/%d\n", result_num, result_denom);

  return 0;
}
```
예시 실행 결과:

python
코드 복사
Enter first fraction: 5/6
Enter second fraction: 3/4
The sum is 38/24
참고로, 결과 분수는 기약분수로 약분되지 않았다.


## _**Q&A**_
Q: 정수를 읽고 쓸 때 %i 변환을 사용하는 것을 본 적이 있어요. %i와 %d의 차이점은 무엇인가요? [p. 39]
A: printf 형식 문자열에서는 두 변환 사이에 차이가 없습니다. 그러나 scanf 형식 문자열에서는 차이가 있습니다. %d는 10진수(기수 10)로 작성된 정수만 일치시킬 수 있는 반면, %i는 8진수(기수 8), 10진수, 16진수(기수 16)로 표현된 정수를 일치시킬 수 있습니다. 예를 들어, 입력 숫자에 접두사 0이 붙어 있다면(예: 056), %i는 이를 8진수로 처리합니다. 0x 또는 0X 접두사(예: 0x56)가 붙은 경우에는 16진수로 간주합니다. 숫자를 읽을 때 %i 대신 %d를 사용하면, 사용자가 숫자의 처음에 0을 실수로 입력했을 때 예기치 못한 결과가 발생할 수 있습니다. 이런 함정을 피하기 위해 %d를 사용하는 것을 권장합니다.

Q: printf는 %를 변환 지정자의 시작으로 인식한다고 했는데, 그럼 % 문자를 출력하려면 어떻게 해야 하나요?
A: printf 형식 문자열에 % 문자가 두 번 연속 나타나면, printf는 하나의 % 문자만 출력합니다. 예를 들어, 다음 문장은

```c
printf("Net profit: %d%%\n", profit);
```
다음과 같은 출력을 생성할 수 있습니다:

yaml
코드 복사
Net profit: 10%
Q: \t 이스케이프 시퀀스는 printf가 다음 탭 정지점으로 이동하게 만든다고 하던데, 탭 정지점 간격은 어떻게 알 수 있나요? [p. 41]
A: 알 수 없습니다. \t를 출력할 때의 효과는 C 언어에서 정의되어 있지 않으며, 운영 체제가 탭 문자를 어떻게 처리하느냐에 따라 달라집니다. 일반적으로 탭 정지점은 8 문자 간격이지만, C는 이를 보장하지 않습니다.

Q: scanf가 숫자를 읽으려고 할 때, 사용자가 숫자가 아닌 문자를 입력하면 어떻게 되나요?
A: 다음 예제를 살펴봅시다:

```c
printf("Enter a number: ");
scanf("%d", &i);
```
사용자가 유효한 숫자 다음에 숫자가 아닌 문자를 입력했다고 가정합시다:

css
코드 복사
Enter a number: 23foo
이 경우, scanf는 2와 3을 읽어 i에 23을 저장합니다. 나머지 문자(foo)는 이후 scanf나 다른 입력 함수에서 읽을 수 있도록 남겨둡니다.
한편, 입력이 처음부터 잘못되었다면:

css
코드 복사
Enter a number: foo
이 경우 i의 값은 정의되지 않으며, foo는 다음 scanf에서 읽기 위해 그대로 남겨집니다.

이러한 안타까운 상황을 어떻게 처리할 수 있을까요?
나중에 우리는 scanf 호출이 성공했는지를 테스트하는 방법을 보게 될 것입니다. 호출이 실패하면, 프로그램을 종료시키거나, 잘못된 입력을 폐기하고 사용자에게 다시 입력하도록 요청할 수 있습니다. (잘못된 입력을 버리는 방법은 22장 끝의 Q&A에서 설명됩니다.)

Q: scanf가 어떻게 문자를 “되돌려 넣고” 나중에 다시 읽을 수 있는지 이해가 되지 않아요. [p. 44]
A: 실제로 프로그램은 사용자가 입력하는 대로 실시간으로 입력을 읽지 않습니다. 대신, 입력은 숨겨진 버퍼에 저장되며, scanf는 이 버퍼에 접근할 수 있습니다. 따라서 scanf가 문자를 버퍼로 되돌리는 것은 간단합니다. 입력 버퍼링에 대해서는 22장에서 더 자세히 설명됩니다.

Q: 사용자가 숫자 사이에 쉼표 같은 구두점을 넣으면 scanf는 어떻게 하나요?
A: 간단한 예를 들어보겠습니다. 정수 두 개를 읽으려고 한다고 가정해 봅시다:

```c
printf("Enter two numbers: ");
scanf("%d%d", &i, &j);
```
사용자가 다음과 같이 입력한다고 가정합시다:

코드 복사
4,28
scanf는 4를 읽고 i에 저장합니다. 그 다음 두 번째 숫자의 시작을 찾으려고 할 때 쉼표를 만나게 됩니다. 숫자는 쉼표로 시작할 수 없기 때문에 scanf는 즉시 반환하고, 쉼표와 두 번째 숫자는 다음 scanf 호출로 남겨둡니다.

물론, 숫자 사이에 항상 쉼표가 있을 거라는 확신이 있다면 형식 문자열에 쉼표를 추가함으로써 이 문제를 쉽게 해결할 수 있습니다:

```c
printf("Enter two numbers, separated by a comma: ");
scanf("%d,%d", &i, &j);
```






