---
title: 2장 C 기초
date: 2025-01-02
categories: [C]
tags: [C]
math: true
---
이 장에서는 전처리 지시문, 함수, 변수, 문장 등 가장 간단한 프로그램을 작성하는 데 필요한 몇 가지 기본 개념을 소개한다. 이후의 장에서는 이러한 주제들을 훨씬 더 자세히 다룰 것이다.

우선 2.1절에서는 간단한 C 프로그램을 소개하고, 이를 컴파일하고 링크하는 방법을 설명한다. 그 다음 2.2절에서는 이 프로그램을 일반화하는 방법을 다루고, 2.3절에서는 설명을 덧붙이는 주석을 추가하는 방법을 보여준다. 2.4절에서는 실행 중에 변경될 수 있는 데이터를 저장하는 변수에 대해 소개하고, 2.5절에서는 scanf 함수를 사용하여 데이터를 변수에 읽어들이는 방법을 보여준다. 프로그램 실행 중 변경되지 않을 데이터(상수)는 이름을 부여할 수 있는데, 이는 2.6절에서 설명한다. 마지막으로 2.7절에서는 C에서 이름(식별자)을 만드는 규칙을 설명하고, 2.8절에서는 프로그램을 구성하는 방법에 대한 규칙을 소개한다.

## _**2.1 간단한 프로그램 작성**_
일부 언어로 작성된 프로그램과는 달리, C 프로그램은 “보일러플레이트”가 거의 필요 없다—완전한 프로그램이 몇 줄이면 충분할 수 있다.

### **프로그램: 말장난 출력하기**
커니핸과 리치의 고전적인 책 『The C Programming Language』의 첫 번째 프로그램은 매우 짧다; 이 프로그램은 단지 “hello, world”라는 메시지를 출력할 뿐이다. 나는 다른 C 저자들과 달리 이 프로그램을 첫 예제로 사용하지 않을 것이다. 그러나 또 다른 C 전통인 ‘말장난(pun)’은 따를 것이다. 다음은 그 말장난이다:

To C, or not to C: that is the question.
(‘C 할 것인가, 말 것인가: 그것이 문제로다.’)

다음 프로그램은 우리가 pun.c라 이름 붙일 것이며, 실행될 때마다 위의 메시지를 출력한다:
```c
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
2.2절에서는 이 프로그램의 형태를 좀 더 자세히 설명한다. 지금은 간단히 몇 가지 사항만 짚고 넘어가자.
```c
#include <stdio.h>
```
이 줄은 C의 표준 입출력 라이브러리에 대한 정보를 “포함”하기 위해 필요하다. 프로그램의 실행 코드(executable code)는 main 안에 들어간다. main은 “주 프로그램(main program)”을 나타낸다. main 안에는 단 한 줄의 명령이 있으며, 이 명령은 원하는 메시지를 화면에 출력한다.

printf는 표준 입출력 라이브러리의 함수로, 형식을 갖춘 출력을 생성할 수 있다. \n 코드는 printf에게 메시지를 출력한 후 다음 줄로 이동하라고 지시한다.

```c
return 0;
```
이 줄은 프로그램이 종료될 때 운영 체제에 값 0을 “반환”한다는 의미이다.

### **컴파일 및 링크**
짧은 코드임에도 불구하고 pun.c를 실행되게 만드는 과정은 예상보다 복잡할 수 있다.

우선, 텍스트 편집기를 사용하여 pun.c라는 이름의 파일을 만들고 프로그램을 입력해야 한다(파일 이름은 중요하지 않지만, 대부분의 컴파일러는 .c 확장자를 요구한다).

다음으로, 이 프로그램을 기계가 실행할 수 있는 형태로 변환해야 한다. 일반적으로 C 프로그램은 세 단계를 거친다:

- 전처리(Preprocessing): 프로그램은 먼저 전처리기에 전달되며, 전처리기는 #로 시작하는 명령(지시문)을 처리한다. 전처리기는 편집기와 비슷한 역할을 하며, 프로그램에 내용을 추가하거나 수정할 수 있다.

- 컴파일(Compiling): 수정된 프로그램은 컴파일러에 의해 기계어(객체 코드)로 번역된다. 그러나 아직 실행 가능한 상태는 아니다.

- 링크(Linking): 마지막 단계에서 링커는 컴파일러가 생성한 객체 코드에 필요한 추가 코드를 결합하여 완전한 실행 파일을 생성한다. 이 추가 코드는 프로그램에서 사용된 라이브러리 함수들(예: printf)을 포함한다.

다행히도 이 과정은 종종 자동화되어 있으므로 크게 번거롭지 않다. 사실 전처리기는 보통 컴파일러에 통합되어 있어 우리가 알아채지 못할 수도 있다.

컴파일 및 링크 명령은 컴파일러와 운영 체제에 따라 다르다. 유닉스에서는 C 컴파일러가 보통 cc라는 이름이다. pun.c를 컴파일하고 링크하려면 터미널이나 명령어 창에서 다음 명령을 입력하면 된다:

```shell
% cc pun.c
```
(% 문자는 유닉스 프롬프트이며, 입력할 필요는 없다.)

cc를 사용할 경우 링크는 자동으로 이루어진다; 별도의 링크 명령은 필요 없다. 컴파일이 완료되면, cc는 기본적으로 실행 파일을 a.out이라는 이름의 파일에 저장한다. cc에는 다양한 옵션이 있으며, 그중 하나인 -o 옵션을 사용하면 실행 파일의 이름을 지정할 수 있다. 예를 들어, pun.c의 실행 파일 이름을 pun으로 하고 싶다면 다음 명령을 입력하면 된다:

```shell
% cc -o pun pun.c
```

> _**GCC 컴파일러**_
가장 널리 사용되는 C 컴파일러 중 하나는 GCC 컴파일러이며, 이는 리눅스에 기본적으로 포함되어 있지만 다른 많은 플랫폼에서도 사용할 수 있다. 이 컴파일러를 사용하는 방법은 전통적인 유닉스 cc와 비슷하다. 예를 들어, pun.c를 컴파일하려면 다음 명령을 사용한다:
```shell
% gcc -o pun pun.c
```
이 장의 마지막 Q&A 섹션에서는 GCC에 대한 추가 정보를 제공한다.

### **통합 개발 환경(IDE)**
지금까지는 운영 체제에서 제공하는 특별한 창(명령줄)에서 명령을 입력하여 컴파일러를 실행하는 “커맨드라인” 컴파일러를 사용하는 것을 가정했다. 다른 방법은 통합 개발 환경(IDE)을 사용하는 것이다. IDE는 프로그램을 편집, 컴파일, 링크, 실행, 심지어 디버깅까지 하나의 환경 안에서 할 수 있게 해주는 소프트웨어 패키지다.

IDE의 구성 요소들은 함께 작동하도록 설계되어 있다. 예를 들어, 컴파일러가 프로그램에서 오류를 감지하면, 편집기가 그 오류가 있는 줄을 강조표시할 수 있다. IDE들 사이에는 많은 차이가 있기 때문에 이 책에서는 더 이상 다루지 않는다. 그러나 사용 중인 플랫폼에서 사용 가능한 IDE가 무엇인지 알아보는 것이 좋다.

## _**2.2 간단한 프로그램의 일반적인 형식**_
pun.c를 좀 더 자세히 살펴보고, 이를 어떻게 일반화할 수 있을지 알아보자. 간단한 C 프로그램은 다음과 같은 형태를 가진다:

```c
directives

int main(void)
{
	statements
}
```
이 책의 템플릿들에서 Courier체로 인쇄된 항목은 C 프로그램에서 정확히 그대로 입력해야 할 항목이며, 이탤릭체는 프로그래머가 작성해야 할 부분을 나타낸다.

중괄호 { }는 main 함수의 시작과 끝을 나타낸다. C는 {와 }를 사용하여 다른 언어에서 begin과 end 같은 단어들이 쓰이는 부분을 표시한다. 이는 C에 대한 일반적인 특징을 보여준다: C는 축약형과 특수 기호에 크게 의존하며, 이로 인해 C 프로그램은 간결하게(혹은 덜 우호적인 표현으로는 난해하게) 보일 수 있다.

가장 간단한 C 프로그램이라 해도 세 가지 핵심 언어 기능에 의존한다: 지시문(directives), 함수(functions), **문장(statements)**이다. 지금부터 이 기능들을 좀 더 자세히 살펴보자.

### **지시문**
C 프로그램은 컴파일되기 전에 먼저 전처리기에 의해 편집된다. 전처리기를 위한 명령은 지시문(directives) 이라고 불린다. 지시문에 대해서는 14장과 15장에서 자세히 다룬다. 지금은 #include 지시문에만 관심을 가지자.

pun.c 프로그램은 다음 줄로 시작한다:

```c
#include <stdio.h>
```
이 지시문은 <stdio.h>에 있는 정보를 컴파일 전에 프로그램에 “포함”시키라는 의미이다. <stdio.h>는 C의 표준 입출력 라이브러리에 대한 정보를 담고 있다. C는 <stdio.h>와 같은 여러 개의 헤더를 가지고 있으며, 각각은 표준 라이브러리의 일부에 대한 정보를 포함한다.

C는 일부 프로그래밍 언어와 달리 기본적으로 “읽기(read)”나 “쓰기(write)” 명령을 내장하고 있지 않다. 대신 입출력 기능은 표준 라이브러리의 함수들에 의해 제공된다.

지시문은 항상 # 문자로 시작하며, 이는 프로그램 내의 다른 항목들과 구별하기 위해서이다. 기본적으로 지시문은 한 줄로 구성되며, 끝에 세미콜론이나 다른 특수 기호가 붙지 않는다.

### **함수**
함수는 다른 프로그래밍 언어의 “프로시저” 또는 “서브루틴”과 유사하다—프로그램이 구성되는 기본 단위이다. 사실, C 프로그램은 함수들의 모음이라고 할 수 있다.

함수는 두 가지 유형으로 나뉜다: 프로그래머가 작성한 함수와 C 구현에 포함된 함수. 후자는 컴파일러와 함께 제공되는 함수들의 “라이브러리”에 속하므로 라이브러리 함수라고 부르겠다.

“함수”라는 용어는 수학에서 유래되었으며, 이는 하나 이상의 인자가 주어졌을 때 값을 계산하는 규칙이다:

$$f(x) = x + 1$$
$$g(y, z) = y² – z²$$

C에서는 이 용어를 더 느슨하게 사용한다. C에서 함수는 단순히 일련의 문장을 그룹으로 묶고 이름을 붙인 것이다. 어떤 함수는 값을 계산하고, 어떤 함수는 그렇지 않다. 값을 계산하는 함수는 return 문을 사용하여 반환할 값을 지정한다. 예를 들어, 인자에 1을 더하는 함수는 다음 문장을 실행할 수 있다:

```c
return x + 1;
```
두 수의 제곱 차를 계산하는 함수는 다음과 같이 할 수 있다:
```c
return y * y - z * z;
```
C 프로그램은 여러 함수로 구성될 수 있지만, 반드시 있어야 하는 함수는 main 함수뿐이다. main은 특별하다: 프로그램이 실행되면 자동으로 호출된다. 9장에서 다른 함수를 작성하는 법을 배우기 전까지는, 우리 프로그램에는 main 함수만 존재할 것이다.

main이라는 이름은 매우 중요하다; begin이나 start, 심지어 MAIN으로도 대체할 수 없다.

main이 함수라면 값을 반환할까? 그렇다: 프로그램이 종료될 때 운영 체제에 상태 코드를 반환한다. 다시 한 번 pun.c 프로그램을 살펴보자:
```c
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
main 앞의 int는 main 함수가 정수 값을 반환함을 나타낸다. 괄호 안의 void는 main이 인자를 받지 않는다는 뜻이다.
```c
return 0;
```
이 문장은 두 가지 역할을 한다: main 함수의 실행을 종료시키며(따라서 프로그램을 종료시킴), main 함수가 0 값을 반환함을 나타낸다. main의 반환값에 대해서는 나중 장에서 더 자세히 다룰 것이다. 지금은 항상 main이 0을 반환하도록 하자; 이는 정상적인 프로그램 종료를 의미한다.

main 함수 끝에 return 문이 없더라도 프로그램은 종료된다. 그러나 많은 컴파일러는 함수가 정수를 반환하기로 되어 있음에도 값을 반환하지 않았다며 경고 메시지를 출력할 것이다.

### **문장**
문장(statement) 은 프로그램이 실행될 때 수행되는 명령이다. 문장에 대해서는 책의 후반부, 특히 5장과 6장에서 자세히 다룬다. pun.c 프로그램은 두 가지 종류의 문장만 사용한다. 하나는 return 문이고, 다른 하나는 함수 호출(function call) 이다. 함수에 특정 작업을 수행하도록 요청하는 것을 함수 호출이라 한다. 예를 들어 pun.c는 printf 함수를 호출하여 화면에 문자열을 출력한다:

```c
printf("To C, or not to C: that is the question.\n");
```
C는 각 문장의 끝에 반드시 세미콜론을 붙여야 한다. (모든 좋은 규칙이 그렇듯, 예외가 하나 있다: 복합 문장(compound statement), 나중에 배우게 된다.) 세미콜론은 컴파일러에게 문장의 끝을 알려준다; 문장이 여러 줄에 걸쳐 있을 수 있기 때문에, 어디서 끝나는지 명확하지 않을 수 있다. 반면, 지시문은 기본적으로 한 줄이며 끝에 세미콜론이 없다.

###문자열 출력
printf는 강력한 함수이며, 3장에서 자세히 다룬다. 지금까지는 단지 printf를 사용하여 문자열 리터럴—쌍따옴표로 둘러싸인 문자들의 연속—을 출력했다. printf가 문자열 리터럴을 출력할 때는 따옴표는 출력되지 않는다.

printf는 메시지 출력 후 자동으로 다음 줄로 넘어가지 않는다. 줄을 바꾸려면 출력할 문자열 안에 \n(줄 바꿈 문자)를 포함시켜야 한다. 줄 바꿈 문자를 작성하면 현재 출력 줄이 종료되며, 이후 출력은 다음 줄에서 시작된다.

이 점을 설명하기 위해 다음과 같은 변경을 생각해 보자:

```c
printf("To C, or not to C: ");
printf("that is the question.\n");
```
첫 번째 printf는 "To C, or not to C: "를 출력한다. 두 번째 printf는 "that is the question."을 출력하고 줄을 바꾼다. 최종 결과는 원래 printf와 동일하다—사용자는 차이를 알 수 없다.

줄 바꿈 문자는 문자열 리터럴 내에 여러 번 등장할 수 있다. 예를 들어 다음 메시지를 출력하려면:

```
Brevity is the soul of wit.
  --Shakespeare
```
다음과 같이 작성할 수 있다:
```c
printf("Brevity is the soul of wit.\n  --Shakespeare\n");
```

## _**2.3 주석 (Comments)**_
pun.c 프로그램에는 여전히 중요한 무언가가 빠져 있다: 문서화이다. 모든 프로그램은 식별 정보를 포함해야 한다: 프로그램 이름, 작성 날짜, 작성자, 프로그램의 목적 등. C에서는 이 정보를 주석(comment) 안에 넣는다. 기호 /*는 주석의 시작을 표시하고, */는 주석의 끝을 표시한다:

```c
/* This is a comment */
```
주석은 프로그램 내 거의 어디에나 위치할 수 있으며, 별도의 줄에 있거나 다른 프로그램 코드와 같은 줄에 있을 수도 있다. pun.c에 프로그램 시작 부분에 주석을 추가하면 다음과 같을 수 있다:

```c
/* Name: pun.c                */
/* Purpose: Prints a bad pun. */
/* Author: K. N. King         */
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
주석은 여러 줄에 걸쳐 확장될 수 있다; 컴파일러는 /* 기호를 본 이후 */ 기호를 만날 때까지 그 사이의 내용을 읽고(그리고 무시한다). 원한다면, 일련의 짧은 주석들을 하나의 긴 주석으로 결합할 수도 있다:
```c
/* Name: pun.c
   Purpose: Prints a bad pun.
   Author: K. N. King */
```
하지만 이러한 형식의 주석은 읽기 어려울 수 있다. 주석의 끝이 어디인지 쉽게 보이지 않기 때문이다. */를 한 줄에 따로 두는 것이 더 좋다:
```c
/* Name: pun.c
   Purpose: Prints a bad pun.
   Author: K. N. King
 */
```
더 좋은 방법은 주석 주위에 “박스(box)”를 만들어서 눈에 띄게 만드는 것이다:
```c
/**********************************************************
 * Name: pun.c                                            *
 * Purpose: Prints a bad pun.                             *
 * Author: K. N. King                                     *
 **********************************************************/
```
프로그래머들은 박스형 주석을 단순화하기 위해 세 변을 생략하곤 한다:
```c
/*
 * Name: pun.c
 * Purpose: Prints a bad pun.
 * Author: K. N. King
 */
```
짧은 주석은 다른 코드와 같은 줄에 올 수 있다:
```c
int main(void)   /* Beginning of main program */
```
이런 형식의 주석은 가끔 “날개 주석(winged comment)”이라 불린다.

주석을 종료하는 것을 잊으면, 컴파일러가 프로그램의 일부를 무시할 수 있다. 다음 예를 보자:
```c
printf("My ");    /* forgot to close this comment...
printf("cat ");
printf("has ");   /* so it ends here */
printf("fleas");
```
첫 번째 주석을 종료하지 않았기 때문에, 컴파일러는 중간의 두 문장을 무시하고, 이 예제는 "My fleas"만 출력한다.

C99는 두 번째 형식의 주석을 제공한다. //(슬래시 두 개)로 시작하는 주석이다:
```c
// This is a comment
```
이 스타일의 주석은 자동으로 줄 끝에서 종료된다. 여러 줄짜리 주석을 만들고자 한다면, 이전 방식(/* … */)을 사용하거나 각 주석 줄마다 //를 붙이면 된다:

```c
// Name: pun.c
// Purpose: Prints a bad pun.
// Author: K. N. King
```
이 새로운 주석 스타일에는 중요한 장점이 몇 가지 있다. 첫째, 주석이 줄 끝에서 자동으로 종료되기 때문에 주석 종료를 깜빡하여 프로그램의 일부를 실수로 무시하는 일이 없다. 둘째, 여러 줄 주석이 잘 드러나는데, 각 줄마다 //를 붙여야 하기 때문이다.

## _**2.4 변수와 대입 (Variables and Assignment)_**
2.1절의 프로그램처럼 단순한 프로그램은 드물다. 대부분의 프로그램은 출력을 내기 전에 일련의 계산을 수행해야 하며, 따라서 실행 중 데이터를 임시로 저장할 방법이 필요하다. C에서는 대부분의 프로그래밍 언어와 마찬가지로, 이러한 저장 위치를 변수(variable) 라고 한다.

자료형 (Types)
모든 변수는 자료형(type) 을 가져야 하며, 이는 어떤 종류의 데이터를 저장할 수 있는지를 지정한다. C에는 매우 다양한 자료형이 있지만, 지금은 int와 float 두 가지만 다루겠다. 적절한 자료형을 선택하는 것은 매우 중요하다. 자료형은 변수가 어떻게 저장되는지, 그리고 어떤 연산을 수행할 수 있는지를 결정한다. 수치형 변수의 자료형은 그 변수가 저장할 수 있는 최대/최소 숫자를 결정하며, 소수점 이하 숫자가 허용되는지도 좌우한다.

int형 변수는 0, 1, 392, –2553 등 정수를 저장할 수 있다. 가능한 값의 범위는 제한적이며, 보통 최대값은 2,147,483,647이지만, 어떤 시스템에서는 32,767일 수도 있다.

float형 변수는 int보다 훨씬 큰 숫자를 저장할 수 있으며, 소수점 이하 자릿수가 있는 수치(예: 379.125)도 저장할 수 있다. 그러나 float형에는 단점이 있다. float 숫자에 대한 연산은 int보다 느릴 수 있으며, 무엇보다도 float 변수의 값은 저장한 값의 근사값에 불과한 경우가 많다. 예를 들어, 0.1을 float 변수에 저장하면 나중에 0.09999999999999987 같은 값이 저장되어 있을 수 있다(반올림 오류 때문이다).

선언 (Declarations)
변수를 사용하기 전에 반드시 선언해야 한다—즉, 컴파일러에게 그 변수에 대해 알려야 한다. 변수 선언은 먼저 자료형을 지정하고, 그 다음 변수 이름을 작성한다. (변수 이름은 2.7절에서 설명하는 규칙을 따라 프로그래머가 정한다.)

예를 들어, height와 profit 변수를 선언하려면 다음과 같이 한다:
```c
int height;
float profit;
```
첫 번째 선언은 height가 int형 변수임을 뜻하며, 정수 값을 저장할 수 있다는 뜻이다. 두 번째 선언은 profit이 float형 변수임을 의미한다.

같은 자료형의 여러 변수를 동시에 선언할 수 있다:
```c
int height, length, width, volume;
float profit, loss;
```
각 선언문은 반드시 세미콜론으로 끝나야 한다.

앞서 본 main의 첫 번째 템플릿에는 선언이 없었지만, main 안에 선언이 들어가야 할 경우에는 문장보다 앞에 와야 한다:
```c
int main(void)
{
  declarations
  statements
}
```
이는 함수 전반에 해당되며(9장에서 더 배운다), 중첩된 선언이 포함된 블록에도 마찬가지다. 스타일 면에서, 선언과 문장 사이에 빈 줄을 넣는 것이 좋다.

C99에서는 선언이 반드시 문장보다 앞에 올 필요는 없다. 예를 들어 main은 선언, 문장, 또 다른 선언을 포함할 수 있다. 하지만 이 책에서는 구식 컴파일러와의 호환성을 위해 이러한 C99 기능은 사용하지 않는다. C++와 Java에서는 변수를 필요할 때 선언하는 것이 일반적이며, 이 관행은 C99에서도 점점 흔해질 것이다.

대입 (Assignment)
변수에 값을 부여하려면 대입을 사용한다. 예를 들어 다음 문장들은:
```c
height = 8;
length = 12;
width = 10;
```
height, length, width에 각각 상수 값을 대입한다. 이 숫자들(8, 12, 10)은 상수(constants) 라고 한다.

변수는 값을 대입하거나 다른 방식으로 사용되기 전에 반드시 선언되어야 한다. 따라서 다음은 허용된다:
```c
int height;
height = 8;
```
하지만 다음은 틀렸다:
```c
height = 8;   /*** 잘못됨 ***/
int height;
```
소수점을 포함한 값을 float 변수에 대입할 경우, 보통 상수는 소수점을 포함한다. 예를 들어 profit이 float 변수라면:
```c
profit = 2150.48;
```
이 때 f 접미어(“float”을 의미)를 붙이는 것이 좋다:
```c
profit = 2150.48f;
```
f를 생략하면 컴파일러가 경고를 출력할 수 있다.

일반적으로 int형 변수에는 int형 값을, float형 변수에는 float형 값을 대입해야 한다. 다른 자료형을 혼합할 수도 있지만, 항상 안전한 것은 아니다—4.2절에서 더 배운다.

변수에 값이 대입되면, 그 값을 이용해 다른 변수 값을 계산할 수 있다:

```c
height = 8;
length = 12;
width = 10;
volume = height * length * width;   /* volume은 이제 960 */
```
C에서 *는 곱셈 연산자이다. 따라서 이 문장은 height, length, width에 저장된 값을 곱한 뒤 결과를 volume에 저장한다. 일반적으로, 대입문의 오른쪽은 상수, 변수, 연산자가 포함된 식(expression)이 될 수 있다.



### **변수 값 출력**
printf를 사용하여 변수의 현재 값을 출력할 수 있다. 예를 들어 height 변수의 현재 값을 다음과 같은 메시지로 출력하려면:

```
Height: h
```
다음처럼 printf를 사용한다:
```c
printf("Height: %d\n", height);
```
%d는 height의 값이 출력될 위치를 나타내는 플레이스홀더이다. \n은 줄을 바꾸라는 지시이다.

- %d는 int형 변수에만 사용된다.

- float형 변수를 출력하려면 %f를 사용한다.

기본적으로 %f는 소수점 아래 6자리까지 출력한다. 소수점 아래 자릿수를 지정하고 싶다면 %.2f처럼 작성할 수 있다. 예를 들어 다음과 같은 줄을 출력하고자 한다면:

```
Profit: $2150.48
```
다음과 같이 쓴다:
```c
printf("Profit: $%.2f\n", profit);
```
printf 한 번으로 출력할 변수 개수에는 제한이 없다. 예를 들어 height와 length 두 변수의 값을 출력하려면:
```c
printf("Height: %d  Length: %d\n", height, length);
```

### **프로그램: 상자의 부피중량 계산**
운송 회사는 크지만 가벼운 박스를 좋아하지 않는다. 트럭이나 비행기의 귀중한 공간을 차지하기 때문이다. 실제로, 이런 박스에는 실제 무게 대신 부피에 따라 추가 요금을 부과하는 경우가 많다. 미국에서는 일반적으로 부피를 166으로 나누어 계산한다(허용된 입방인치/파운드 수). 이 값(“부피중량(dimensional weight)” 또는 “체적무게(volumetric weight)”)이 실제 무게보다 크면, 운송 요금은 부피중량 기준으로 책정된다. (국제 운송의 경우 나눗셈의 기준값은 166이며, 국내 운송은 보통 194를 사용한다.)

운송 회사에 입사한 당신은 박스의 부피중량을 계산하는 프로그램을 작성하게 되었다. C를 처음 배우는 중이라면, 우선 가로 12", 세로 10", 높이 8"인 특정 박스의 부피중량을 계산하는 간단한 프로그램부터 시작할 수 있다.

C에서 나눗셈은 /로 표현된다. 따라서 다음과 같이 작성할 수 있을 것 같다:

```c
weight = volume / 166;
```
여기서 weight와 volume은 정수형 변수이다. 그러나 이 공식은 정확하지 않다. C에서 정수끼리 나누면 결과는 소수점 이하가 버려진다. 예를 들어 12×10×8의 부피는 960이다. 166으로 나누면 5.783이지만, C에서는 그냥 5가 된다. 즉, **내림(round down)**이 일어난다. 반면, 운송 회사는 **올림(round up)**을 기대한다.

해결 방법은 나누기 전에 165를 더하는 것이다:
```c
weight = (volume + 165) / 166;
```
부피가 166이면 331/166 = 1, 부피가 167이면 332/166 = 2가 된다. 이 방법을 사용하면 원하는 결과를 얻을 수 있다.

다음은 이 계산을 수행하는 프로그램이다:
```c
/* Computes the dimensional weight of a 12" x 10" x 8" box */
#include <stdio.h>

int main(void)
{
  int height, length, width, volume, weight;
  height = 8;
  length = 12;
  width = 10;
  volume = height * length * width;
  weight = (volume + 165) / 166;

  printf("Dimensions: %dx%dx%d\n", length, width, height);
  printf("Volume (cubic inches): %d\n", volume);
  printf("Dimensional weight (pounds): %d\n", weight);
  return 0;
}
```
프로그램 출력은 다음과 같다:
```c
Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6
```
### **초기화 (Initialization)**
일부 변수는 프로그램이 시작될 때 자동으로 0으로 초기화되지만, 대부분은 그렇지 않다. 기본값이 없고 아직 값을 할당받지 않은 변수는 초기화되지 않은 변수(uninitialized variable) 라고 한다.

초기화되지 않은 변수의 값을 참조하려고 하면(예: printf로 출력하거나 식에서 사용하려고 하면), 결과는 예측할 수 없는 숫자(예: 2568, –30891, 또는 다른 이상한 숫자)가 될 수 있다. 어떤 컴파일러에서는 더 나쁜 결과—심지어 프로그램 충돌이 발생할 수도 있다.

물론 변수에 값을 할당하여 초기화할 수 있다. 하지만 더 쉬운 방법은 변수를 선언할 때 초기값을 함께 지정하는 것이다. 예:
```c
int height = 8;
```
C 용어로는, 8은 초기자(initializer) 라고 불린다.

여러 변수를 동시에 초기화할 수 있다:
```c
int height = 8, length = 12, width = 10;
```
각 변수는 자신의 초기값을 가져야 한다. 다음 예에서는 width만 초기화되고, height와 length는 그렇지 않다:
```c
int height, length, width = 10;
```

### **식의 출력**
printf는 변수에 저장된 숫자만 출력할 수 있는 게 아니다. 임의의 숫자식(expression) 의 값을 출력할 수 있다. 이를 활용하면 프로그램이 더 단순해지고, 변수 수를 줄일 수 있다.

예를 들어 다음 문장들:
```c
volume = height * length * width;
printf("%d\n", volume);
```
을 다음 한 줄로 바꿀 수 있다:

```c
printf("%d\n", height * length * width);
```
printf가 식을 출력할 수 있다는 점은 C의 일반 원칙 중 하나를 잘 보여준다: 값이 필요한 곳에는, 같은 형식의 아무 식이나 사용할 수 있다.

## _**2.5 입력 읽기 (Reading Input)**_
dweight.c 프로그램은 단 하나의 박스에 대해서만 부피중량을 계산하므로 그다지 유용하지 않다. 프로그램을 개선하려면, 사용자가 박스의 치수를 입력할 수 있도록 해야 한다.

입력을 받기 위해, 우리는 scanf 함수를 사용할 것이다. 이 함수는 printf에 대응되는 C 라이브러리 함수이다. scanf와 printf에서 f는 “formatted”(형식화된)를 의미한다; 두 함수 모두 형식 문자열(format string)의 사용을 요구하며, 이는 입력 또는 출력 데이터의 형식을 지정하는 역할을 한다. scanf는 입력 데이터가 어떤 형식으로 들어올지를 알아야 하며, 이는 printf가 출력 데이터를 어떻게 표시할지를 알아야 하는 것과 같다.

정수 값을 읽기 위해서는 scanf를 다음과 같이 사용한다:
```c
scanf("%d", &i);   /* 정수를 읽어서 i에 저장 */
```
"%d" 문자열은 scanf에게 정수를 읽으라고 지시한다; i는 우리가 scanf를 통해 입력 값을 저장하고자 하는 int 변수이다. 여기서 & 기호는 지금 단계에서 설명하기 어려운 개념이지만, 현재로서는 scanf를 사용할 때 대개(하지만 항상은 아님) 필요하다고만 알아두자.

실수 값을 읽기 위해서는 약간 다른 방식으로 scanf를 호출해야 한다:
```c
scanf("%f", &x);   /* 실수 값을 읽어서 x에 저장 */
```
%f는 float 형 변수에만 사용되므로, 여기서 x는 float 변수라고 가정한다. "%f" 문자열은 scanf에게 실수 형식의 입력 값을 찾으라고 지시한다(숫자에 소수점이 포함될 수도 있고, 없을 수도 있다).

### **프로그램: 박스의 부피중량 계산 (다시 보기)**
다음은 사용자가 박스의 치수를 입력할 수 있도록 개선된 부피중량 프로그램이다. 각 scanf 호출은 직전에 printf 호출을 포함하고 있다. 이렇게 하면 사용자는 언제 입력해야 하며 무엇을 입력해야 하는지 알 수 있다.

```c
/* Computes the dimensional weight of a
   box from input provided by the user */
#include <stdio.h>

int main(void)
{
  int height, length, width, volume, weight;

  printf("Enter height of box: ");
  scanf("%d", &height);

  printf("Enter length of box: ");
  scanf("%d", &length);

  printf("Enter width of box: ");
  scanf("%d", &width);

  volume = height * length * width;
  weight = (volume + 165) / 166;

  printf("Volume (cubic inches): %d\n", volume);
  printf("Dimensional weight (pounds): %d\n", weight);

  return 0;
}
```
프로그램의 출력은 다음과 같은 형태를 가진다(밑줄 친 부분은 사용자가 입력한 내용이다):

```
Enter height of box: 8
Enter length of box: 12
Enter width of box: 10
Volume (cubic inches): 960
Dimensional weight (pounds): 6
```
사용자에게 입력을 요청하는 메시지(프롬프트)는 보통 줄 바꿈 문자를 포함하지 않는다. 왜냐하면 사용자에게 프롬프트와 같은 줄에 입력하도록 유도하고 싶기 때문이다. 사용자가 Enter 키를 누르면 커서는 자동으로 다음 줄로 이동한다—줄을 종료하기 위해 프로그램이 줄 바꿈 문자를 출력할 필요는 없다.

dweight2.c 프로그램에는 한 가지 문제가 있다: 사용자가 숫자가 아닌 값을 입력할 경우 제대로 작동하지 않는다. 이 문제는 3.2절에서 좀 더 자세히 다룬다.

## _**2.6 상수에 이름 정의하기 (Defining Names for Constants)**_
프로그램에 상수가 포함되어 있다면, 그 상수에 이름을 부여하는 것이 좋은 생각인 경우가 많다. dweight.c와 dweight2.c 프로그램은 166이라는 상수에 의존하는데, 이 상수가 무엇을 의미하는지 나중에 프로그램을 읽는 사람에게는 전혀 명확하지 않을 수 있다. 매크로 정의(macro definition) 라는 기능을 사용하여 이 상수에 이름을 붙일 수 있다:
```c
#define INCHES_PER_POUND 166
```

#define은 #include처럼 전처리 지시문이므로, 줄 끝에 세미콜론이 붙지 않는다.

프로그램이 컴파일될 때, 전처리기는 각 매크로를 그것이 나타내는 값으로 대체한다. 예를 들어 다음 문장은:
```c
weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND;
```
다음과 같이 변환된다:

```c
weight = (volume + 166 - 1) / 166;
```
이는 우리가 처음부터 이렇게 작성한 것과 동일한 효과를 낸다.

매크로 값은 식(expression)이 될 수도 있다:

```c
#define RECIPROCAL_OF_PI (1.0f / 3.14159f)
```
연산자를 포함한 식이라면 괄호로 감싸는 것이 좋다.

우리는 매크로 이름에 대문자만 사용했다. 이것은 C 프로그래머 대부분이 따르는 관례이며, 언어의 요구 사항은 아니다. (그렇더라도 C 프로그래머들은 수십 년 동안 이를 지켜왔으며, 여러분이 처음으로 이를 어기고 싶어 하지는 않을 것이다.)

프로그램: 화씨에서 섭씨로 변환하기
다음 프로그램은 사용자에게 화씨 온도를 입력하라고 요청한 다음, 이에 해당하는 섭씨 온도를 출력한다. 프로그램의 출력은 다음과 같은 형태를 가진다(밑줄 친 부분은 사용자가 입력한 내용이다):

```
Enter Fahrenheit temperature: 212
Celsius equivalent: 100.0
```
이 프로그램은 정수가 아닌 온도 값도 허용한다. 그렇기 때문에 섭씨 온도는 100이 아니라 100.0으로 출력된다. 먼저 전체 프로그램을 보고, 그 구성 방식을 살펴보자.

```c
/* Converts a Fahrenheit temperature to Celsius */
#include <stdio.h>
#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)

int main(void)
{
  float fahrenheit, celsius;

  printf("Enter Fahrenheit temperature: ");
  scanf("%f", &fahrenheit);

  celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

  printf("Celsius equivalent: %.1f\n", celsius);

  return 0;
}
```
다음 문장은:
```c
celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
```
화씨 온도를 섭씨 온도로 변환한다. FREEZING_PT가 32.0f, SCALE_FACTOR가 (5.0f / 9.0f)를 나타내므로, 컴파일러는 이 문장을 다음과 같이 본다:

```c
celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);
```
SCALE_FACTOR를 (5.0f / 9.0f)로 정의한 것은 중요하다. 왜냐하면 두 정수를 나누면 C는 결과를 잘라낸다(truncate). (5 / 9)의 값은 0이 될 것이며, 이것은 우리가 원하는 결과가 절대 아니다.

printf 호출은 섭씨 온도를 출력한다:

```c
printf("Celsius equivalent: %.1f\n", celsius);
```
여기서 %.1f를 사용하여 소수점 아래 한 자리만 출력하도록 했다.

## _**2.7 식별자 (Identifiers)**_
프로그램을 작성하면서, 우리는 변수, 함수, 매크로 및 기타 항목에 대해 이름을 선택해야 한다. 이러한 이름들을 식별자(identifier) 라고 한다. C에서 식별자는 문자, 숫자, 밑줄을 포함할 수 있지만, 반드시 문자나 밑줄로 시작해야 한다. (C99에서는 식별자에 특정한 “유니버설 문자 이름(universal character names)”도 포함할 수 있다.)

다음은 합법적인 식별자의 예이다:
times10 get_next_char _done

다음은 합법적이지 않은 식별자의 예이다:
10times get-next-char
10times는 숫자로 시작하기 때문에, get-next-char는 밑줄이 아니라 빼기 기호(-) 를 포함하기 때문에 유효하지 않다.

C는 대소문자를 구분(case-sensitive) 한다: 식별자에서 대문자와 소문자를 서로 다르게 취급한다. 예를 들어 다음 식별자들은 모두 서로 다른 것으로 간주된다:
job joB jOb jOB Job JoB JOb JOB
이 여덟 개의 식별자는 동시에 사용될 수 있으며, 각각 완전히 다른 목적을 가질 수 있다. (난독화의 끝판왕이다!) 합리적인 프로그래머는 관련이 없는 경우, 식별자를 다르게 보이도록 만든다.

대소문자가 구분되므로, 많은 프로그래머는 매크로를 제외한 식별자에는 소문자만 사용하고, 가독성을 위해 밑줄(_)을 삽입하는 관례를 따른다:

symbol_table

current_page

name_and_address

다른 프로그래머들은 밑줄을 피하고, 각 단어의 첫 글자를 대문자로 만드는 방법을 사용한다:

symbolTable

currentPage

nameAndAddress
(가끔 첫 글자까지 대문자로 쓰기도 한다.) 전통적인 C에서는 전자의 스타일이 더 일반적이지만, 후자의 스타일은 Java와 C#에서 널리 사용됨에 따라 점점 인기를 끌고 있다(C++에서도 어느 정도 사용됨). 다른 합리적인 관례들도 존재하며, 중요한 점은 식별자를 프로그램 내에서 항상 같은 방식으로 대문자를 사용하는 것이다.

C는 식별자의 최대 길이에 제한을 두지 않으므로, 긴 설명적인 이름을 사용하는 것을 두려워하지 말라. 예를 들어 current_page라는 이름은 cp보다 훨씬 이해하기 쉽다.

### **키워드 (Keywords)**
다음 표(Table 2.1)의 키워드는 C 컴파일러에게 특별한 의미를 가지므로, 식별자로 사용할 수 없다. C99에서는 다섯 개의 키워드가 새로 추가되었다:

키워드 목록
auto
break
case
char
const
continue
default
do
double
else

† = C99 전용

C가 대소문자를 구분하기 때문에, 키워드는 위 표에 나와 있는 그대로 소문자로 프로그램에 사용되어야 한다. 표준 라이브러리 함수들의 이름(예: printf)도 소문자만 포함한다. 모든 프로그램을 대문자로 입력해서 키워드나 라이브러리 함수 호출을 컴파일러가 인식하지 못하게 되는 불쌍한 프로그래머의 전철을 밟지 않도록 주의하라.

기타 식별자에 대한 제약도 주의해야 한다. 일부 컴파일러는 특정 식별자(예: asm)를 추가 키워드로 간주한다. 표준 라이브러리에 속하는 식별자들도 제한된다. 이러한 이름을 실수로 사용하면 컴파일 오류나 링크 오류가 발생할 수 있다. 밑줄로 시작하는 식별자도 제한된다.

C 프로그램의 레이아웃 (Layout of a C Program)
C 프로그램은 토큰(token) 들의 연속으로 생각할 수 있다: 의미를 바꾸지 않고는 분리할 수 없는 문자들의 그룹이다. 식별자와 키워드는 토큰이다. 연산자(+, -), 구두점(,, ;), 문자열 리터럴 등도 모두 토큰이다.

예를 들어 다음 문장:

```c
printf("Height: %d\n", height);
은 일곱 개의 토큰으로 구성되어 있다:

➀ printf
➁ (
➂ "Height: %d\n"
➃ ,
➄ height
➅ )
➆ ;

➀과 ➄는 식별자

➂은 문자열 리터럴

나머지는 구두점이다

대부분의 경우, 토큰 사이의 공백은 중요하지 않다. 극단적으로는, 토큰을 거의 붙여서 작성할 수도 있다. 다만 토큰 두 개가 합쳐져 제3의 토큰이 되지 않도록 주의해야 한다.

예를 들어, 2.6절의 celsius.c 프로그램에서 다음과 같이 거의 모든 공백을 제거할 수 있다:

```c
/* Converts a Fahrenheit temperature to Celsius */
#include <stdio.h>
#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f/9.0f)
int main(void){float fahrenheit,celsius;printf("Enter Fahrenheit temperature: ");scanf("%f", &fahrenheit);celsius=(fahrenheit-FREEZING_PT)*SCALE_FACTOR;printf("Celsius equivalent: %.1f\n", celsius);return 0;}
```
만약 페이지가 더 넓었다면 main 함수 전체를 한 줄로 작성할 수도 있었을 것이다. 하지만 전체 프로그램은 한 줄에 쓸 수 없다. 전처리 지시문은 각각 별도의 줄에 있어야 하기 때문이다.

이렇게 프로그램을 압축하는 것은 좋은 생각이 아니다. 오히려 공백과 빈 줄을 넣으면 프로그램이 더 읽기 쉽고 이해하기 쉬워진다. 다행히도 C는 토큰 사이에 공백 문자(공백, 탭, 줄바꿈)를 얼마든지 삽입할 수 있게 허용한다. 이 규칙은 프로그램 레이아웃에 있어 여러 중요한 결과를 낳는다:

문장들은 여러 줄로 나뉠 수 있다.
예를 들어 다음 문장은 너무 길어서 한 줄에 쓰기 힘들다:

```c
printf("Dimensional weight (pounds): %d\n",
       (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND);
```
토큰 사이에 공백을 두면 읽기 쉬워진다.
그래서 나는 연산자 앞뒤에 공백을 둔다:

```c
volume = height * length * width;
```
또 나는 쉼표 뒤에도 공백을 둔다. 어떤 프로그래머는 괄호 주변에도 공백을 두기도 한다.

들여쓰기는 중첩을 명확하게 만든다.
예를 들어 main 안에 있는 선언과 문장을 들여쓰면, 그것들이 main 안에 속한다는 것이 명확해진다.

빈 줄은 논리적 단위를 구분할 수 있게 해준다.
빈 줄이 없는 프로그램은 장(chapter) 이 없는 책처럼 읽기 어렵다.

2.6절의 celsius.c 프로그램은 이러한 지침 몇 가지를 잘 보여준다. 그 main 함수를 다시 보자:

```c
int main(void)
{
  float fahrenheit, celsius;

  printf("Enter Fahrenheit temperature: ");
  scanf("%f", &fahrenheit);

  celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

  printf("Celsius equivalent: %.1f\n", celsius);

  return 0;
}
```
먼저, =, -, * 주변에 있는 공백은 연산자들을 눈에 띄게 만든다.

둘째, 선언과 문장을 들여쓰면 이것들이 모두 main 안에 있다는 것이 명확해진다.

마지막으로, 빈 줄은 main을 다섯 부분으로 나눈다:

fahrenheit와 celsius 변수 선언

화씨 온도 입력 받기

섭씨 계산

섭씨 출력

운영체제로 종료값 반환

프로그램 레이아웃 얘기가 나왔으니, 나는 { 토큰을 main() 아래에 두고, 이에 대응하는 }를 별도의 줄에 두어 {와 정렬시킨다. 이렇게 하면 함수 끝에 문장을 삽입하거나 삭제할 수 있고, main의 끝이 한눈에 들어온다.

마지막 주의사항:
토큰 사이에 공백은 삽입할 수 있지만, 토큰 안에 공백을 넣는 것은 오류를 일으키거나 프로그램의 의미를 바꾼다. 예:

```c
fl oat fahrenheit, celsius;  /*** 잘못됨 ***/
```

```c
fl
oat fahrenheit, celsius;    /*** 잘못됨 ***/
```
문자열 리터럴 내에는 공백을 넣을 수 있지만, 그 의미는 변경된다. 그러나 문자열을 줄바꿈하여 두 줄에 나누는 것은 불법이다:

```c
printf("To C, or not to C:
that is the question.\n");  /*** 잘못됨 ***/
```
문자열을 여러 줄에 나누려면 특별한 기법이 필요하며, 이는 뒷장에서 배울 것이다.a

## _**Q & A**_
Q: GCC는 무엇의 약자인가요? [p. 11]
A: GCC는 원래 “GNU C Compiler”의 약자였습니다. 그러나 현재의 GCC는 여러 언어로 작성된 프로그램을 컴파일할 수 있으므로, “GNU Compiler Collection”의 약자로 사용됩니다. 현재 GCC는 Ada, C, C++, Fortran, Java, Objective-C 등 다양한 언어를 컴파일할 수 있습니다.

Q: 그렇다면 GNU는 무엇의 약자인가요?
A: GNU는 “GNU’s Not UNIX!”의 약자이며, 발음은 “그-뉴(guh-NEW)”입니다. GNU는 Free Software Foundation(자유 소프트웨어 재단)의 프로젝트로, Richard M. Stallman이 라이선스 제한이 있는 UNIX 소프트웨어에 대한 항의로 설립했습니다. Free Software Foundation의 웹사이트에 따르면, 이 재단은 사용자가 소프트웨어를 “실행, 복사, 배포, 연구, 변경 및 향상”시킬 수 있어야 한다고 믿습니다. GNU 프로젝트는 전통적인 UNIX 소프트웨어를 처음부터 새로 작성하였으며, 이를 무료로 공개했습니다.

GCC 및 기타 GNU 소프트웨어는 Linux에 필수적입니다. Linux 자체는 운영체제의 “커널”(프로그램 스케줄링 및 기본 입출력 서비스를 처리하는 부분)일 뿐이며, GNU 소프트웨어가 있어야 완전한 운영체제가 완성됩니다.

GNU 프로젝트에 대한 더 많은 정보를 원하신다면, www.gnu.org을 방문해 보세요.

Q: GCC가 왜 그렇게 중요한가요?
A: GCC가 중요한 이유는 다양하지만, 가장 큰 이유는 무료이고 여러 언어를 컴파일할 수 있기 때문입니다. GCC는 다양한 운영체제에서 실행되며, 광범위하게 사용되는 모든 CPU용 코드를 생성할 수 있습니다. GCC는 Linux, BSD, Mac OS X를 포함한 많은 UNIX 기반 운영체제의 기본 컴파일러이며, 상용 소프트웨어 개발에서도 광범위하게 사용됩니다. GCC에 대한 더 많은 정보를 원하신다면 gcc.gnu.org를 방문해 보세요.

Q: GCC는 프로그램의 오류를 얼마나 잘 찾아내나요?
A: GCC에는 프로그램을 얼마나 철저히 검사할지를 제어하는 다양한 명령줄 옵션이 있습니다. 이러한 옵션을 사용하면, GCC는 프로그램 내 잠재적인 문제를 상당히 잘 찾아낼 수 있습니다. 대표적인 옵션은 다음과 같습니다:

-Wall
모든 일반적인 경고 메시지를 표시합니다.

-W
특정 경고 코드를 지정하여 더 많은 경고를 표시할 수 있습니다.

-pedantic
C 표준에 따라 필요한 모든 경고 메시지를 표시하며, 비표준적인 기능을 사용하는 프로그램을 거부합니다.

-ansi
GCC의 비표준 기능을 끄고, 일부 표준 기능을 활성화합니다.

-std=c89, -std=c99
컴파일러가 프로그램을 검사할 때 사용할 C 버전을 지정합니다.

이러한 옵션은 일반적으로 조합하여 사용합니다:

shell
코드 복사
% gcc -O -Wall -W -pedantic -ansi -std=c99 -o pun pun.c
Q: C는 왜 이렇게 간결한가요? begin과 end를 쓰는 대신 {와 }를 쓰고, integer 대신 int를 쓰는 이유는 무엇인가요? [p. 12]
A: 전설에 따르면, C 프로그램이 이렇게 간결하게 된 이유는 C가 개발된 벨 연구소의 환경 때문이라고 합니다. 최초의 C 컴파일러는 DEC PDP-11이라는 초기 미니컴퓨터에서 작동했으며, 프로그래머들은 전신 타자기(teletype) — 실질적으로 컴퓨터에 연결된 타자기 — 를 사용해 프로그램을 입력하고 인쇄했습니다. 타자기는 매우 느렸기 때문에(초당 10자밖에 출력할 수 없었음), 프로그램의 문자 수를 줄이는 것이 분명한 이점이 있었습니다.

Q: 일부 C 책에서는 main 함수의 끝에 return 0 대신 exit(0)을 사용합니다. 두 문장은 같은 역할을 하나요? [p. 14]
A: main 함수 안에 있을 때, 이 두 문장은 사실상 동일합니다: 둘 다 프로그램을 종료하고 운영체제에 0을 반환합니다. 어떤 것을 사용할지는 대부분 취향의 문제입니다.

Q: main 함수의 끝에 return 문이 없으면 어떻게 되나요? [p. 14]
A: return 문은 필수 사항은 아닙니다; 없더라도 프로그램은 종료됩니다.

C89에서는 반환값이 정의되지 않음

C99에서는 main이 int를 반환하도록 선언되어 있다면(이 책의 예제들처럼), 자동으로 0을 반환합니다. 그렇지 않으면 반환값은 불특정값입니다.

Q: 컴파일러는 주석을 완전히 제거하나요, 아니면 공백으로 대체하나요?
A: 예전 C 컴파일러는 각 주석의 문자를 모두 삭제했기 때문에, 다음과 같은 코드가 가능했습니다:

c
코드 복사
a/**/b = 0;
이는 컴파일러에 의해 ab = 0;으로 해석되었죠.
하지만 C 표준에 따르면, 컴파일러는 각 주석을 공백 문자 하나로 대체해야 합니다. 따라서 위의 예는 다음과 같이 변환되어 잘못된 문장이 됩니다:

c
코드 복사
a b = 0;
Q: 프로그램에 미종료 주석(unterminated comment)이 있는지 어떻게 알 수 있나요?
A: 운이 좋으면, 주석이 프로그램을 불법적인 형태로 만들어 컴파일이 되지 않을 것입니다. 만약 프로그램이 컴파일된다면, 다음과 같은 기법들을 사용할 수 있습니다:

디버거를 사용해 프로그램을 한 줄씩 실행해 보면, 어떤 줄이 건너뛰어졌는지 확인할 수 있습니다.

일부 IDE는 주석을 특별한 색상으로 표시하므로, 주석이 닫히지 않은 경우 색상이 바뀌어 쉽게 식별할 수 있습니다.

lint 같은 프로그램도 이런 문제를 찾아내는 데 도움이 됩니다.

Q: 한 주석 안에 또 다른 주석을 중첩하는 것이 가능한가요?
A: 기존 스타일 주석(/* ... */)은 중첩이 불가능합니다. 예를 들어 다음 코드는 불법입니다:

c
코드 복사
/*
/*** WRONG ***/
*/
두 번째 줄의 */가 첫 번째 줄의 /*와 짝을 이루기 때문에, 세 번째 줄의 */는 컴파일 오류로 표시됩니다.

C에서 중첩 주석을 금지하는 것은 때때로 문제가 됩니다. 예를 들어, 많은 짧은 주석이 포함된 긴 프로그램이 있고, 프로그램 일부를 일시적으로 비활성화(예: 테스트 중)하고 싶다면, 처음에는 /*와 */를 사용해 해당 줄을 주석 처리하고 싶어질 수 있습니다. 그러나 그 줄들에 기존 스타일 주석이 포함되어 있다면, 이 방법은 작동하지 않습니다.

C99 스타일 주석(//)은 기존 주석 안에 중첩될 수 있습니다. 이것이 이 스타일의 주석을 사용하는 또 다른 장점입니다.

어쨌든, 프로그램의 일부를 비활성화하는 더 좋은 방법이 있으며, 이에 대해서는 나중에 배울 것입니다.

Q: float라는 형식 이름은 어디에서 유래했나요? [p. 17]
A: float는 “floating-point”(부동 소수점)의 줄임말입니다. 이는 소수점이 “떠다니는” 방식으로 숫자를 저장하는 기법입니다. 일반적으로 float 값은 두 부분으로 저장됩니다: 분수(또는 맨티사)와 지수. 예를 들어, 숫자 12.0은 1.5 × 2³으로 저장될 수 있으며, 여기서 1.5는 분수, 3은 지수입니다. 일부 프로그래밍 언어에서는 이 형식을 real이라고 부르기도 합니다.

Q: 왜 부동 소수점 상수는 f 문자로 끝나야 하나요? [p. 19]
A: 전체 설명은 7장에서 다루지만, 간단히 말하자면: 소수점이 포함된 상수가 f로 끝나지 않으면, 그 상수는 double 형입니다 (double은 “double precision”, 즉 두 배 정밀도라는 의미). double 값은 float보다 더 정확하게 저장되며, 더 큰 값을 저장할 수 있습니다.

따라서 float 변수에 값을 저장할 때 f를 붙이지 않으면, 변수가 표현할 수 있는 범위를 초과할 가능성에 대해 컴파일러가 경고를 발생시킬 수 있습니다.

Q: 식별자의 길이에 제한이 정말 없나요? [p. 26]
A: 그렇기도 하고, 아니기도 합니다.

C89 표준은 식별자가 임의의 길이를 가질 수 있다고 말합니다.

그러나 컴파일러는 처음 31자까지만 기억하면 충분합니다(C99에서는 63자). 따라서 두 식별자가 처음 31자가 같다면, 컴파일러가 둘을 구분하지 못할 수 있습니다.

상황을 더 복잡하게 만드는 것은, 외부 연결(external linkage) 을 갖는 식별자에 대한 특별 규칙이 존재한다는 점입니다. 대부분의 함수 이름은 여기에 속합니다. 이러한 이름들은 링커가 사용할 수 있어야 하며, 일부 오래된 링커는 짧은 이름만 처리할 수 있습니다. 따라서 C89에서는 처음 여섯 글자만 유효하며, 대소문자는 중요하지 않을 수 있습니다. 그 결과, ABCDEFG와 abcdefh는 같은 이름으로 간주될 수 있습니다.

(C99에서는 처음 31자까지만 중요하고, 대소문자도 구분합니다.)

대부분의 현대 컴파일러와 링커는 이보다 관대하므로, 실제로는 문제가 되지 않습니다.
식별자를 너무 길게 만드는 것보다, 너무 짧게 만드는 것이 더 문제입니다.

Q: 들여쓰기를 몇 칸으로 해야 하나요? [p. 28]
A: 어려운 질문입니다.

공간이 너무 적으면, 눈으로 들여쓰기를 식별하기 어렵습니다.

공간이 너무 많으면, 줄이 화면(또는 페이지)을 벗어날 수 있습니다.

많은 C 프로그래머는 중첩된 문장을 8칸(탭 하나) 들여쓰지만, 이건 너무 많을 수도 있습니다. 연구에 따르면, 이상적인 들여쓰기 간격은 3칸이라고 합니다. 그러나 많은 프로그래머들은 2의 거듭제곱이 아닌 숫자를 꺼려합니다.

나는 보통 3칸 또는 4칸을 선호하지만, 이 책에서는 지면 제약으로 인해 들여쓰기를 2칸으로 사용했습니다.







