이 장에서는 전처리 지시문, 함수, 변수, 문장 등 가장 간단한 프로그램을 작성하는 데 필요한 몇 가지 기본 개념을 소개한다. 이후의 장에서는 이러한 주제들을 훨씬 더 자세히 다룰 것이다.

우선 2.1절에서는 간단한 C 프로그램을 소개하고, 이를 컴파일하고 링크하는 방법을 설명한다. 그 다음 2.2절에서는 이 프로그램을 일반화하는 방법을 다루고, 2.3절에서는 설명을 덧붙이는 주석을 추가하는 방법을 보여준다. 2.4절에서는 실행 중에 변경될 수 있는 데이터를 저장하는 변수에 대해 소개하고, 2.5절에서는 scanf 함수를 사용하여 데이터를 변수에 읽어들이는 방법을 보여준다. 프로그램 실행 중 변경되지 않을 데이터(상수)는 이름을 부여할 수 있는데, 이는 2.6절에서 설명한다. 마지막으로 2.7절에서는 C에서 이름(식별자)을 만드는 규칙을 설명하고, 2.8절에서는 프로그램을 구성하는 방법에 대한 규칙을 소개한다.

## _**2.1 간단한 프로그램 작성**_
일부 언어로 작성된 프로그램과는 달리, C 프로그램은 “보일러플레이트”가 거의 필요 없다—완전한 프로그램이 몇 줄이면 충분할 수 있다.

### **프로그램: 말장난 출력하기**
커니핸과 리치의 고전적인 책 『The C Programming Language』의 첫 번째 프로그램은 매우 짧다; 이 프로그램은 단지 “hello, world”라는 메시지를 출력할 뿐이다. 나는 다른 C 저자들과 달리 이 프로그램을 첫 예제로 사용하지 않을 것이다. 그러나 또 다른 C 전통인 ‘말장난(pun)’은 따를 것이다. 다음은 그 말장난이다:

To C, or not to C: that is the question.
(‘C 할 것인가, 말 것인가: 그것이 문제로다.’)

다음 프로그램은 우리가 pun.c라 이름 붙일 것이며, 실행될 때마다 위의 메시지를 출력한다:
```c
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
2.2절에서는 이 프로그램의 형태를 좀 더 자세히 설명한다. 지금은 간단히 몇 가지 사항만 짚고 넘어가자.
```c
#include <stdio.h>
```
이 줄은 C의 표준 입출력 라이브러리에 대한 정보를 “포함”하기 위해 필요하다. 프로그램의 실행 코드(executable code)는 main 안에 들어간다. main은 “주 프로그램(main program)”을 나타낸다. main 안에는 단 한 줄의 명령이 있으며, 이 명령은 원하는 메시지를 화면에 출력한다.

printf는 표준 입출력 라이브러리의 함수로, 형식을 갖춘 출력을 생성할 수 있다. \n 코드는 printf에게 메시지를 출력한 후 다음 줄로 이동하라고 지시한다.

```c
return 0;
```
이 줄은 프로그램이 종료될 때 운영 체제에 값 0을 “반환”한다는 의미이다.

### **컴파일 및 링크**
짧은 코드임에도 불구하고 pun.c를 실행되게 만드는 과정은 예상보다 복잡할 수 있다.

우선, 텍스트 편집기를 사용하여 pun.c라는 이름의 파일을 만들고 프로그램을 입력해야 한다(파일 이름은 중요하지 않지만, 대부분의 컴파일러는 .c 확장자를 요구한다).

다음으로, 이 프로그램을 기계가 실행할 수 있는 형태로 변환해야 한다. 일반적으로 C 프로그램은 세 단계를 거친다:

- 전처리(Preprocessing): 프로그램은 먼저 전처리기에 전달되며, 전처리기는 #로 시작하는 명령(지시문)을 처리한다. 전처리기는 편집기와 비슷한 역할을 하며, 프로그램에 내용을 추가하거나 수정할 수 있다.

- 컴파일(Compiling): 수정된 프로그램은 컴파일러에 의해 기계어(객체 코드)로 번역된다. 그러나 아직 실행 가능한 상태는 아니다.

- 링크(Linking): 마지막 단계에서 링커는 컴파일러가 생성한 객체 코드에 필요한 추가 코드를 결합하여 완전한 실행 파일을 생성한다. 이 추가 코드는 프로그램에서 사용된 라이브러리 함수들(예: printf)을 포함한다.

다행히도 이 과정은 종종 자동화되어 있으므로 크게 번거롭지 않다. 사실 전처리기는 보통 컴파일러에 통합되어 있어 우리가 알아채지 못할 수도 있다.

컴파일 및 링크 명령은 컴파일러와 운영 체제에 따라 다르다. 유닉스에서는 C 컴파일러가 보통 cc라는 이름이다. pun.c를 컴파일하고 링크하려면 터미널이나 명령어 창에서 다음 명령을 입력하면 된다:

```shell
% cc pun.c
```
(% 문자는 유닉스 프롬프트이며, 입력할 필요는 없다.)

cc를 사용할 경우 링크는 자동으로 이루어진다; 별도의 링크 명령은 필요 없다. 컴파일이 완료되면, cc는 기본적으로 실행 파일을 a.out이라는 이름의 파일에 저장한다. cc에는 다양한 옵션이 있으며, 그중 하나인 -o 옵션을 사용하면 실행 파일의 이름을 지정할 수 있다. 예를 들어, pun.c의 실행 파일 이름을 pun으로 하고 싶다면 다음 명령을 입력하면 된다:

```shell
% cc -o pun pun.c
```

> _**GCC 컴파일러**_
가장 널리 사용되는 C 컴파일러 중 하나는 GCC 컴파일러이며, 이는 리눅스에 기본적으로 포함되어 있지만 다른 많은 플랫폼에서도 사용할 수 있다. 이 컴파일러를 사용하는 방법은 전통적인 유닉스 cc와 비슷하다. 예를 들어, pun.c를 컴파일하려면 다음 명령을 사용한다:
```shell
% gcc -o pun pun.c
```
이 장의 마지막 Q&A 섹션에서는 GCC에 대한 추가 정보를 제공한다.

### **통합 개발 환경(IDE)**
지금까지는 운영 체제에서 제공하는 특별한 창(명령줄)에서 명령을 입력하여 컴파일러를 실행하는 “커맨드라인” 컴파일러를 사용하는 것을 가정했다. 다른 방법은 통합 개발 환경(IDE)을 사용하는 것이다. IDE는 프로그램을 편집, 컴파일, 링크, 실행, 심지어 디버깅까지 하나의 환경 안에서 할 수 있게 해주는 소프트웨어 패키지다.

IDE의 구성 요소들은 함께 작동하도록 설계되어 있다. 예를 들어, 컴파일러가 프로그램에서 오류를 감지하면, 편집기가 그 오류가 있는 줄을 강조표시할 수 있다. IDE들 사이에는 많은 차이가 있기 때문에 이 책에서는 더 이상 다루지 않는다. 그러나 사용 중인 플랫폼에서 사용 가능한 IDE가 무엇인지 알아보는 것이 좋다.

## _**2.2 간단한 프로그램의 일반적인 형식**_
pun.c를 좀 더 자세히 살펴보고, 이를 어떻게 일반화할 수 있을지 알아보자. 간단한 C 프로그램은 다음과 같은 형태를 가진다:

```c
directives

int main(void)
{
	statements
}
```
이 책의 템플릿들에서 Courier체로 인쇄된 항목은 C 프로그램에서 정확히 그대로 입력해야 할 항목이며, 이탤릭체는 프로그래머가 작성해야 할 부분을 나타낸다.

중괄호 { }는 main 함수의 시작과 끝을 나타낸다. C는 {와 }를 사용하여 다른 언어에서 begin과 end 같은 단어들이 쓰이는 부분을 표시한다. 이는 C에 대한 일반적인 특징을 보여준다: C는 축약형과 특수 기호에 크게 의존하며, 이로 인해 C 프로그램은 간결하게(혹은 덜 우호적인 표현으로는 난해하게) 보일 수 있다.

가장 간단한 C 프로그램이라 해도 세 가지 핵심 언어 기능에 의존한다: 지시문(directives), 함수(functions), **문장(statements)**이다. 지금부터 이 기능들을 좀 더 자세히 살펴보자.

### **지시문**
C 프로그램은 컴파일되기 전에 먼저 전처리기에 의해 편집된다. 전처리기를 위한 명령은 지시문(directives) 이라고 불린다. 지시문에 대해서는 14장과 15장에서 자세히 다룬다. 지금은 #include 지시문에만 관심을 가지자.

pun.c 프로그램은 다음 줄로 시작한다:

```c
#include <stdio.h>
```
이 지시문은 <stdio.h>에 있는 정보를 컴파일 전에 프로그램에 “포함”시키라는 의미이다. <stdio.h>는 C의 표준 입출력 라이브러리에 대한 정보를 담고 있다. C는 <stdio.h>와 같은 여러 개의 헤더를 가지고 있으며, 각각은 표준 라이브러리의 일부에 대한 정보를 포함한다.

C는 일부 프로그래밍 언어와 달리 기본적으로 “읽기(read)”나 “쓰기(write)” 명령을 내장하고 있지 않다. 대신 입출력 기능은 표준 라이브러리의 함수들에 의해 제공된다.

지시문은 항상 # 문자로 시작하며, 이는 프로그램 내의 다른 항목들과 구별하기 위해서이다. 기본적으로 지시문은 한 줄로 구성되며, 끝에 세미콜론이나 다른 특수 기호가 붙지 않는다.

### **함수**
함수는 다른 프로그래밍 언어의 “프로시저” 또는 “서브루틴”과 유사하다—프로그램이 구성되는 기본 단위이다. 사실, C 프로그램은 함수들의 모음이라고 할 수 있다.

함수는 두 가지 유형으로 나뉜다: 프로그래머가 작성한 함수와 C 구현에 포함된 함수. 후자는 컴파일러와 함께 제공되는 함수들의 “라이브러리”에 속하므로 라이브러리 함수라고 부르겠다.

“함수”라는 용어는 수학에서 유래되었으며, 이는 하나 이상의 인자가 주어졌을 때 값을 계산하는 규칙이다:

$$f(x) = x + 1$$
$$g(y, z) = y² – z²$$

C에서는 이 용어를 더 느슨하게 사용한다. C에서 함수는 단순히 일련의 문장을 그룹으로 묶고 이름을 붙인 것이다. 어떤 함수는 값을 계산하고, 어떤 함수는 그렇지 않다. 값을 계산하는 함수는 return 문을 사용하여 반환할 값을 지정한다. 예를 들어, 인자에 1을 더하는 함수는 다음 문장을 실행할 수 있다:

```c
return x + 1;
```
두 수의 제곱 차를 계산하는 함수는 다음과 같이 할 수 있다:
```c
return y * y - z * z;
```
C 프로그램은 여러 함수로 구성될 수 있지만, 반드시 있어야 하는 함수는 main 함수뿐이다. main은 특별하다: 프로그램이 실행되면 자동으로 호출된다. 9장에서 다른 함수를 작성하는 법을 배우기 전까지는, 우리 프로그램에는 main 함수만 존재할 것이다.

main이라는 이름은 매우 중요하다; begin이나 start, 심지어 MAIN으로도 대체할 수 없다.

main이 함수라면 값을 반환할까? 그렇다: 프로그램이 종료될 때 운영 체제에 상태 코드를 반환한다. 다시 한 번 pun.c 프로그램을 살펴보자:
```c
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
main 앞의 int는 main 함수가 정수 값을 반환함을 나타낸다. 괄호 안의 void는 main이 인자를 받지 않는다는 뜻이다.
```c
return 0;
```
이 문장은 두 가지 역할을 한다: main 함수의 실행을 종료시키며(따라서 프로그램을 종료시킴), main 함수가 0 값을 반환함을 나타낸다. main의 반환값에 대해서는 나중 장에서 더 자세히 다룰 것이다. 지금은 항상 main이 0을 반환하도록 하자; 이는 정상적인 프로그램 종료를 의미한다.

main 함수 끝에 return 문이 없더라도 프로그램은 종료된다. 그러나 많은 컴파일러는 함수가 정수를 반환하기로 되어 있음에도 값을 반환하지 않았다며 경고 메시지를 출력할 것이다.

### **문장**
문장(statement) 은 프로그램이 실행될 때 수행되는 명령이다. 문장에 대해서는 책의 후반부, 특히 5장과 6장에서 자세히 다룬다. pun.c 프로그램은 두 가지 종류의 문장만 사용한다. 하나는 return 문이고, 다른 하나는 함수 호출(function call) 이다. 함수에 특정 작업을 수행하도록 요청하는 것을 함수 호출이라 한다. 예를 들어 pun.c는 printf 함수를 호출하여 화면에 문자열을 출력한다:

```c
printf("To C, or not to C: that is the question.\n");
```
C는 각 문장의 끝에 반드시 세미콜론을 붙여야 한다. (모든 좋은 규칙이 그렇듯, 예외가 하나 있다: 복합 문장(compound statement), 나중에 배우게 된다.) 세미콜론은 컴파일러에게 문장의 끝을 알려준다; 문장이 여러 줄에 걸쳐 있을 수 있기 때문에, 어디서 끝나는지 명확하지 않을 수 있다. 반면, 지시문은 기본적으로 한 줄이며 끝에 세미콜론이 없다.

###문자열 출력
printf는 강력한 함수이며, 3장에서 자세히 다룬다. 지금까지는 단지 printf를 사용하여 문자열 리터럴—쌍따옴표로 둘러싸인 문자들의 연속—을 출력했다. printf가 문자열 리터럴을 출력할 때는 따옴표는 출력되지 않는다.

printf는 메시지 출력 후 자동으로 다음 줄로 넘어가지 않는다. 줄을 바꾸려면 출력할 문자열 안에 \n(줄 바꿈 문자)를 포함시켜야 한다. 줄 바꿈 문자를 작성하면 현재 출력 줄이 종료되며, 이후 출력은 다음 줄에서 시작된다.

이 점을 설명하기 위해 다음과 같은 변경을 생각해 보자:

```c
printf("To C, or not to C: ");
printf("that is the question.\n");
```
첫 번째 printf는 "To C, or not to C: "를 출력한다. 두 번째 printf는 "that is the question."을 출력하고 줄을 바꾼다. 최종 결과는 원래 printf와 동일하다—사용자는 차이를 알 수 없다.

줄 바꿈 문자는 문자열 리터럴 내에 여러 번 등장할 수 있다. 예를 들어 다음 메시지를 출력하려면:

```
Brevity is the soul of wit.
  --Shakespeare
```
다음과 같이 작성할 수 있다:
```c
printf("Brevity is the soul of wit.\n  --Shakespeare\n");
```

## _**2.3 주석 (Comments)**_
pun.c 프로그램에는 여전히 중요한 무언가가 빠져 있다: 문서화이다. 모든 프로그램은 식별 정보를 포함해야 한다: 프로그램 이름, 작성 날짜, 작성자, 프로그램의 목적 등. C에서는 이 정보를 주석(comment) 안에 넣는다. 기호 /*는 주석의 시작을 표시하고, */는 주석의 끝을 표시한다:

```c
/* This is a comment */
```
주석은 프로그램 내 거의 어디에나 위치할 수 있으며, 별도의 줄에 있거나 다른 프로그램 코드와 같은 줄에 있을 수도 있다. pun.c에 프로그램 시작 부분에 주석을 추가하면 다음과 같을 수 있다:

```c
/* Name: pun.c                */
/* Purpose: Prints a bad pun. */
/* Author: K. N. King         */
#include <stdio.h>
int main(void)
{
  printf("To C, or not to C: that is the question.\n");
  return 0;
}
```
주석은 여러 줄에 걸쳐 확장될 수 있다; 컴파일러는 /* 기호를 본 이후 */ 기호를 만날 때까지 그 사이의 내용을 읽고(그리고 무시한다). 원한다면, 일련의 짧은 주석들을 하나의 긴 주석으로 결합할 수도 있다:
```c
/* Name: pun.c
   Purpose: Prints a bad pun.
   Author: K. N. King */
```
하지만 이러한 형식의 주석은 읽기 어려울 수 있다. 주석의 끝이 어디인지 쉽게 보이지 않기 때문이다. */를 한 줄에 따로 두는 것이 더 좋다:
```c
/* Name: pun.c
   Purpose: Prints a bad pun.
   Author: K. N. King
 */
```
더 좋은 방법은 주석 주위에 “박스(box)”를 만들어서 눈에 띄게 만드는 것이다:
```c
/**********************************************************
 * Name: pun.c                                            *
 * Purpose: Prints a bad pun.                             *
 * Author: K. N. King                                     *
 **********************************************************/
```
프로그래머들은 박스형 주석을 단순화하기 위해 세 변을 생략하곤 한다:
```c
/*
 * Name: pun.c
 * Purpose: Prints a bad pun.
 * Author: K. N. King
 */
```
짧은 주석은 다른 코드와 같은 줄에 올 수 있다:
```c
int main(void)   /* Beginning of main program */
```
이런 형식의 주석은 가끔 “날개 주석(winged comment)”이라 불린다.

주석을 종료하는 것을 잊으면, 컴파일러가 프로그램의 일부를 무시할 수 있다. 다음 예를 보자:
```c
printf("My ");    /* forgot to close this comment...
printf("cat ");
printf("has ");   /* so it ends here */
printf("fleas");
```
첫 번째 주석을 종료하지 않았기 때문에, 컴파일러는 중간의 두 문장을 무시하고, 이 예제는 "My fleas"만 출력한다.

C99는 두 번째 형식의 주석을 제공한다. //(슬래시 두 개)로 시작하는 주석이다:
```c
// This is a comment
```
이 스타일의 주석은 자동으로 줄 끝에서 종료된다. 여러 줄짜리 주석을 만들고자 한다면, 이전 방식(/* … */)을 사용하거나 각 주석 줄마다 //를 붙이면 된다:

```c
// Name: pun.c
// Purpose: Prints a bad pun.
// Author: K. N. King
```
이 새로운 주석 스타일에는 중요한 장점이 몇 가지 있다. 첫째, 주석이 줄 끝에서 자동으로 종료되기 때문에 주석 종료를 깜빡하여 프로그램의 일부를 실수로 무시하는 일이 없다. 둘째, 여러 줄 주석이 잘 드러나는데, 각 줄마다 //를 붙여야 하기 때문이다.

## _**2.4 변수와 대입 (Variables and Assignment)_**
2.1절의 프로그램처럼 단순한 프로그램은 드물다. 대부분의 프로그램은 출력을 내기 전에 일련의 계산을 수행해야 하며, 따라서 실행 중 데이터를 임시로 저장할 방법이 필요하다. C에서는 대부분의 프로그래밍 언어와 마찬가지로, 이러한 저장 위치를 변수(variable) 라고 한다.

자료형 (Types)
모든 변수는 자료형(type) 을 가져야 하며, 이는 어떤 종류의 데이터를 저장할 수 있는지를 지정한다. C에는 매우 다양한 자료형이 있지만, 지금은 int와 float 두 가지만 다루겠다. 적절한 자료형을 선택하는 것은 매우 중요하다. 자료형은 변수가 어떻게 저장되는지, 그리고 어떤 연산을 수행할 수 있는지를 결정한다. 수치형 변수의 자료형은 그 변수가 저장할 수 있는 최대/최소 숫자를 결정하며, 소수점 이하 숫자가 허용되는지도 좌우한다.

int형 변수는 0, 1, 392, –2553 등 정수를 저장할 수 있다. 가능한 값의 범위는 제한적이며, 보통 최대값은 2,147,483,647이지만, 어떤 시스템에서는 32,767일 수도 있다.

float형 변수는 int보다 훨씬 큰 숫자를 저장할 수 있으며, 소수점 이하 자릿수가 있는 수치(예: 379.125)도 저장할 수 있다. 그러나 float형에는 단점이 있다. float 숫자에 대한 연산은 int보다 느릴 수 있으며, 무엇보다도 float 변수의 값은 저장한 값의 근사값에 불과한 경우가 많다. 예를 들어, 0.1을 float 변수에 저장하면 나중에 0.09999999999999987 같은 값이 저장되어 있을 수 있다(반올림 오류 때문이다).

선언 (Declarations)
변수를 사용하기 전에 반드시 선언해야 한다—즉, 컴파일러에게 그 변수에 대해 알려야 한다. 변수 선언은 먼저 자료형을 지정하고, 그 다음 변수 이름을 작성한다. (변수 이름은 2.7절에서 설명하는 규칙을 따라 프로그래머가 정한다.)

예를 들어, height와 profit 변수를 선언하려면 다음과 같이 한다:
```c
int height;
float profit;
```
첫 번째 선언은 height가 int형 변수임을 뜻하며, 정수 값을 저장할 수 있다는 뜻이다. 두 번째 선언은 profit이 float형 변수임을 의미한다.

같은 자료형의 여러 변수를 동시에 선언할 수 있다:
```c
int height, length, width, volume;
float profit, loss;
```
각 선언문은 반드시 세미콜론으로 끝나야 한다.

앞서 본 main의 첫 번째 템플릿에는 선언이 없었지만, main 안에 선언이 들어가야 할 경우에는 문장보다 앞에 와야 한다:
```c
int main(void)
{
  declarations
  statements
}
```
이는 함수 전반에 해당되며(9장에서 더 배운다), 중첩된 선언이 포함된 블록에도 마찬가지다. 스타일 면에서, 선언과 문장 사이에 빈 줄을 넣는 것이 좋다.

C99에서는 선언이 반드시 문장보다 앞에 올 필요는 없다. 예를 들어 main은 선언, 문장, 또 다른 선언을 포함할 수 있다. 하지만 이 책에서는 구식 컴파일러와의 호환성을 위해 이러한 C99 기능은 사용하지 않는다. C++와 Java에서는 변수를 필요할 때 선언하는 것이 일반적이며, 이 관행은 C99에서도 점점 흔해질 것이다.

대입 (Assignment)
변수에 값을 부여하려면 대입을 사용한다. 예를 들어 다음 문장들은:
```c
height = 8;
length = 12;
width = 10;
```
height, length, width에 각각 상수 값을 대입한다. 이 숫자들(8, 12, 10)은 상수(constants) 라고 한다.

변수는 값을 대입하거나 다른 방식으로 사용되기 전에 반드시 선언되어야 한다. 따라서 다음은 허용된다:
```c
int height;
height = 8;
```
하지만 다음은 틀렸다:
```c
height = 8;   /*** 잘못됨 ***/
int height;
```
소수점을 포함한 값을 float 변수에 대입할 경우, 보통 상수는 소수점을 포함한다. 예를 들어 profit이 float 변수라면:
```c
profit = 2150.48;
```
이 때 f 접미어(“float”을 의미)를 붙이는 것이 좋다:
```c
profit = 2150.48f;
```
f를 생략하면 컴파일러가 경고를 출력할 수 있다.

일반적으로 int형 변수에는 int형 값을, float형 변수에는 float형 값을 대입해야 한다. 다른 자료형을 혼합할 수도 있지만, 항상 안전한 것은 아니다—4.2절에서 더 배운다.

변수에 값이 대입되면, 그 값을 이용해 다른 변수 값을 계산할 수 있다:

```c
height = 8;
length = 12;
width = 10;
volume = height * length * width;   /* volume은 이제 960 */
```
C에서 *는 곱셈 연산자이다. 따라서 이 문장은 height, length, width에 저장된 값을 곱한 뒤 결과를 volume에 저장한다. 일반적으로, 대입문의 오른쪽은 상수, 변수, 연산자가 포함된 식(expression)이 될 수 있다.



### **변수 값 출력**
printf를 사용하여 변수의 현재 값을 출력할 수 있다. 예를 들어 height 변수의 현재 값을 다음과 같은 메시지로 출력하려면:

```
Height: h
```
다음처럼 printf를 사용한다:
```c
printf("Height: %d\n", height);
```
%d는 height의 값이 출력될 위치를 나타내는 플레이스홀더이다. \n은 줄을 바꾸라는 지시이다.

- %d는 int형 변수에만 사용된다.

- float형 변수를 출력하려면 %f를 사용한다.

기본적으로 %f는 소수점 아래 6자리까지 출력한다. 소수점 아래 자릿수를 지정하고 싶다면 %.2f처럼 작성할 수 있다. 예를 들어 다음과 같은 줄을 출력하고자 한다면:

```
Profit: $2150.48
```
다음과 같이 쓴다:
```c
printf("Profit: $%.2f\n", profit);
```
printf 한 번으로 출력할 변수 개수에는 제한이 없다. 예를 들어 height와 length 두 변수의 값을 출력하려면:
```c
printf("Height: %d  Length: %d\n", height, length);
```

### **프로그램: 상자의 부피중량 계산**
운송 회사는 크지만 가벼운 박스를 좋아하지 않는다. 트럭이나 비행기의 귀중한 공간을 차지하기 때문이다. 실제로, 이런 박스에는 실제 무게 대신 부피에 따라 추가 요금을 부과하는 경우가 많다. 미국에서는 일반적으로 부피를 166으로 나누어 계산한다(허용된 입방인치/파운드 수). 이 값(“부피중량(dimensional weight)” 또는 “체적무게(volumetric weight)”)이 실제 무게보다 크면, 운송 요금은 부피중량 기준으로 책정된다. (국제 운송의 경우 나눗셈의 기준값은 166이며, 국내 운송은 보통 194를 사용한다.)

운송 회사에 입사한 당신은 박스의 부피중량을 계산하는 프로그램을 작성하게 되었다. C를 처음 배우는 중이라면, 우선 가로 12", 세로 10", 높이 8"인 특정 박스의 부피중량을 계산하는 간단한 프로그램부터 시작할 수 있다.

C에서 나눗셈은 /로 표현된다. 따라서 다음과 같이 작성할 수 있을 것 같다:

```c
weight = volume / 166;
```
여기서 weight와 volume은 정수형 변수이다. 그러나 이 공식은 정확하지 않다. C에서 정수끼리 나누면 결과는 소수점 이하가 버려진다. 예를 들어 12×10×8의 부피는 960이다. 166으로 나누면 5.783이지만, C에서는 그냥 5가 된다. 즉, **내림(round down)**이 일어난다. 반면, 운송 회사는 **올림(round up)**을 기대한다.

해결 방법은 나누기 전에 165를 더하는 것이다:
```c
weight = (volume + 165) / 166;
```
부피가 166이면 331/166 = 1, 부피가 167이면 332/166 = 2가 된다. 이 방법을 사용하면 원하는 결과를 얻을 수 있다.

다음은 이 계산을 수행하는 프로그램이다:
```c
/* Computes the dimensional weight of a 12" x 10" x 8" box */
#include <stdio.h>

int main(void)
{
  int height, length, width, volume, weight;
  height = 8;
  length = 12;
  width = 10;
  volume = height * length * width;
  weight = (volume + 165) / 166;

  printf("Dimensions: %dx%dx%d\n", length, width, height);
  printf("Volume (cubic inches): %d\n", volume);
  printf("Dimensional weight (pounds): %d\n", weight);
  return 0;
}
```
프로그램 출력은 다음과 같다:
```c
Dimensions: 12x10x8
Volume (cubic inches): 960
Dimensional weight (pounds): 6
```
### **초기화 (Initialization)**
일부 변수는 프로그램이 시작될 때 자동으로 0으로 초기화되지만, 대부분은 그렇지 않다. 기본값이 없고 아직 값을 할당받지 않은 변수는 초기화되지 않은 변수(uninitialized variable) 라고 한다.

초기화되지 않은 변수의 값을 참조하려고 하면(예: printf로 출력하거나 식에서 사용하려고 하면), 결과는 예측할 수 없는 숫자(예: 2568, –30891, 또는 다른 이상한 숫자)가 될 수 있다. 어떤 컴파일러에서는 더 나쁜 결과—심지어 프로그램 충돌이 발생할 수도 있다.

물론 변수에 값을 할당하여 초기화할 수 있다. 하지만 더 쉬운 방법은 변수를 선언할 때 초기값을 함께 지정하는 것이다. 예:
```c
int height = 8;
```
C 용어로는, 8은 초기자(initializer) 라고 불린다.

여러 변수를 동시에 초기화할 수 있다:
```c
int height = 8, length = 12, width = 10;
```
각 변수는 자신의 초기값을 가져야 한다. 다음 예에서는 width만 초기화되고, height와 length는 그렇지 않다:
```c
int height, length, width = 10;
```

### **식의 출력**
printf는 변수에 저장된 숫자만 출력할 수 있는 게 아니다. 임의의 숫자식(expression) 의 값을 출력할 수 있다. 이를 활용하면 프로그램이 더 단순해지고, 변수 수를 줄일 수 있다.

예를 들어 다음 문장들:
```c
volume = height * length * width;
printf("%d\n", volume);
```
을 다음 한 줄로 바꿀 수 있다:

```c
printf("%d\n", height * length * width);
```
printf가 식을 출력할 수 있다는 점은 C의 일반 원칙 중 하나를 잘 보여준다: 값이 필요한 곳에는, 같은 형식의 아무 식이나 사용할 수 있다.

## _**2.5 입력 읽기 (Reading Input)**_
dweight.c 프로그램은 단 하나의 박스에 대해서만 부피중량을 계산하므로 그다지 유용하지 않다. 프로그램을 개선하려면, 사용자가 박스의 치수를 입력할 수 있도록 해야 한다.

입력을 받기 위해, 우리는 scanf 함수를 사용할 것이다. 이 함수는 printf에 대응되는 C 라이브러리 함수이다. scanf와 printf에서 f는 “formatted”(형식화된)를 의미한다; 두 함수 모두 형식 문자열(format string)의 사용을 요구하며, 이는 입력 또는 출력 데이터의 형식을 지정하는 역할을 한다. scanf는 입력 데이터가 어떤 형식으로 들어올지를 알아야 하며, 이는 printf가 출력 데이터를 어떻게 표시할지를 알아야 하는 것과 같다.

정수 값을 읽기 위해서는 scanf를 다음과 같이 사용한다:
```c
scanf("%d", &i);   /* 정수를 읽어서 i에 저장 */
```
"%d" 문자열은 scanf에게 정수를 읽으라고 지시한다; i는 우리가 scanf를 통해 입력 값을 저장하고자 하는 int 변수이다. 여기서 & 기호는 지금 단계에서 설명하기 어려운 개념이지만, 현재로서는 scanf를 사용할 때 대개(하지만 항상은 아님) 필요하다고만 알아두자.

실수 값을 읽기 위해서는 약간 다른 방식으로 scanf를 호출해야 한다:
```c
scanf("%f", &x);   /* 실수 값을 읽어서 x에 저장 */
```
%f는 float 형 변수에만 사용되므로, 여기서 x는 float 변수라고 가정한다. "%f" 문자열은 scanf에게 실수 형식의 입력 값을 찾으라고 지시한다(숫자에 소수점이 포함될 수도 있고, 없을 수도 있다).

### **프로그램: 박스의 부피중량 계산 (다시 보기)**
다음은 사용자가 박스의 치수를 입력할 수 있도록 개선된 부피중량 프로그램이다. 각 scanf 호출은 직전에 printf 호출을 포함하고 있다. 이렇게 하면 사용자는 언제 입력해야 하며 무엇을 입력해야 하는지 알 수 있다.

```c
/* Computes the dimensional weight of a
   box from input provided by the user */
#include <stdio.h>

int main(void)
{
  int height, length, width, volume, weight;

  printf("Enter height of box: ");
  scanf("%d", &height);

  printf("Enter length of box: ");
  scanf("%d", &length);

  printf("Enter width of box: ");
  scanf("%d", &width);

  volume = height * length * width;
  weight = (volume + 165) / 166;

  printf("Volume (cubic inches): %d\n", volume);
  printf("Dimensional weight (pounds): %d\n", weight);

  return 0;
}
```
프로그램의 출력은 다음과 같은 형태를 가진다(밑줄 친 부분은 사용자가 입력한 내용이다):

```
Enter height of box: 8
Enter length of box: 12
Enter width of box: 10
Volume (cubic inches): 960
Dimensional weight (pounds): 6
```
사용자에게 입력을 요청하는 메시지(프롬프트)는 보통 줄 바꿈 문자를 포함하지 않는다. 왜냐하면 사용자에게 프롬프트와 같은 줄에 입력하도록 유도하고 싶기 때문이다. 사용자가 Enter 키를 누르면 커서는 자동으로 다음 줄로 이동한다—줄을 종료하기 위해 프로그램이 줄 바꿈 문자를 출력할 필요는 없다.

dweight2.c 프로그램에는 한 가지 문제가 있다: 사용자가 숫자가 아닌 값을 입력할 경우 제대로 작동하지 않는다. 이 문제는 3.2절에서 좀 더 자세히 다룬다.
