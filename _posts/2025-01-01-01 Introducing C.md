---
title: 1장 C 소개
date: 2025-04-24
categories: [C]
tags: [C]
math: true
---

C란 무엇인가? 간단한 대답은—1970년대 초 벨 연구소에서 개발된 널리 사용되는 프로그래밍 언어—C의 특별한 매력을 거의 전달하지 못한다. 우리가 이 언어의 세부사항에 몰두하기 전에, 먼저 C가 어디서 비롯되었는지, 무엇을 위해 설계되었는지, 그리고 수년에 걸쳐 어떻게 변화해왔는지를 살펴보자 (1.1절). 우리는 또한 C의 강점과 약점에 대해 논의하고, 언어를 최대한 활용하는 방법을 살펴볼 것이다 (1.2절).

## _**1.1 C의 역사**_
C의 기원을 시작으로, 표준화된 언어로 자리잡기까지, 그리고 최근 언어들에 끼친 영향까지 C의 역사를 간략히 살펴보자.

기원
C는 유닉스(UNIX) 운영 체제의 부산물이다. 유닉스는 벨 연구소(Bell Laboratories)에서 켄 톰슨(Ken Thompson), 데니스 리치(Dennis Ritchie) 등 여러 사람에 의해 개발되었다. 톰슨은 DEC PDP-7 컴퓨터에서 실행되는 유닉스의 원래 버전을 혼자서 작성했는데, 이는 8K 워드의 주 기억 장치만 갖춘 초기 미니컴퓨터였다 (어쨌든 1969년이었으니!).

그 당시의 다른 운영 체제들과 마찬가지로, 유닉스도 어셈블리 언어로 작성되었다. 어셈블리 언어로 작성된 프로그램은 일반적으로 디버깅하기가 고통스럽고 기능을 향상시키기도 어렵다. 유닉스도 예외는 아니었다. 톰슨은 유닉스의 추가 개발을 위해 더 고수준의 언어가 필요하다고 판단했고, 그래서 그는 B라는 작은 언어를 설계했다. 톰슨은 B를 1960년대 중반에 개발된 시스템 프로그래밍 언어인 BCPL에 기반하여 만들었다. BCPL은 다시, 가장 초기이자 (가장 영향력 있는) 프로그래밍 언어 중 하나인 Algol 60에서 그 계보를 찾을 수 있다.

곧 리치는 유닉스 프로젝트에 합류했고, B 언어로 프로그래밍을 시작했다. 1970년, 벨 연구소는 유닉스 프로젝트를 위해 PDP-11 컴퓨터를 도입했다. B가 PDP-11에서 실행되자, 톰슨은 유닉스의 일부를 B로 다시 작성했다. 그러나 1971년쯤에는 B가 PDP-11에 잘 맞지 않는다는 것이 분명해졌고, 리치는 B의 확장 버전을 개발하기 시작했다. 그는 처음에는 자신의 언어를 NB("New B")라고 불렀고, B에서 점점 더 멀어지자 이름을 C로 바꾸었다. 이 언어는 1973년쯤이면 충분히 안정되어 유닉스를 C로 다시 작성할 수 있을 정도였다. C로의 전환은 중요한 이점을 제공했는데, 바로 이식성(portability)이었다. 벨 연구소의 다른 컴퓨터에 대해 C 컴파일러를 작성함으로써, 팀은 유닉스를 다른 기기에서도 실행할 수 있게 했다.

표준화
C는 1970년대 동안 계속 진화했고, 특히 1977년부터 1979년 사이에 많은 변화가 있었다. 이 시기에 C에 대한 첫 번째 책이 등장했다. 브라이언 커니핸(Brian Kernighan)과 데니스 리치(Dennis Ritchie)가 집필하고 1978년에 출판된 『The C Programming Language』는 곧 C 프로그래머들의 바이블이 되었다. C에 대한 공식적인 표준이 존재하지 않았기 때문에, 이 책은 애호가들 사이에서 K&R 또는 "화이트 북(White Book)"이라는 이름으로 불리며 사실상의 표준 역할을 했다.

1970년대 동안에는 C 프로그래머가 비교적 적었고, 대부분이 유닉스 사용자였다. 그러나 1980년대에 접어들면서, C는 유닉스의 좁은 영역을 넘어 확장되기 시작했다. 다양한 운영 체제 하에서 실행되는 여러 기기들에서 C 컴파일러가 사용 가능해졌다. 특히, 빠르게 성장하던 IBM PC 플랫폼에서 C는 입지를 다지기 시작했다.

C의 인기가 증가하면서 문제도 발생했다. 새로운 C 컴파일러를 작성한 프로그래머들은 K&R을 참조자료로 삼았다. 그러나 K&R은 일부 언어 기능에 대해 모호했기 때문에, 컴파일러들이 이러한 기능을 서로 다르게 처리하는 경우가 많았다. 또한, K&R은 어떤 기능이 C에 속하고, 어떤 것이 유닉스의 일부인지 명확히 구분하지 않았다. 문제를 더 악화시킨 것은, K&R 출간 이후에도 C가 계속 변화하여 새로운 기능이 추가되고 일부 오래된 기능이 제거되었다는 점이었다. 언어에 대해 철저하고, 정확하며, 최신의 설명이 필요하다는 사실이 곧 명백해졌다. 이러한 표준이 없다면 수많은 방언(dialects)이 생겨나게 될 것이고, 이는 C 프로그램의 주요 강점 중 하나인 이식성을 위협할 수 있었다.

미국 표준을 개발하는 작업은 1983년 미국국립표준협회(ANSI)의 후원 하에 시작되었다. 여러 차례의 개정 끝에 이 표준은 1988년에 완성되었고, 1989년 12월 ANSI 표준 X3.159-1989로 공식 승인되었다. 1990년에는 국제표준화기구(ISO)에 의해 국제 표준 ISO/IEC 9899:1990으로 승인되었다. 이 언어 버전은 일반적으로 C89 또는 C90으로 불리며, 종종 원래의 C 버전인 K&R C와 구분된다. 부록 C는 C89와 K&R C 사이의 주요 차이점을 요약한다.

C99
언어는 1995년에 몇 가지 변경을 겪었으며, 이는 '개정안 1(Amendment 1)'이라는 문서로 설명되어 있다. 보다 중요한 변경은 1999년에 새로운 표준 ISO/IEC 9899:1999가 발표되면서 발생했다. 이 표준에 기술된 언어는 일반적으로 C99로 알려져 있다. 한때 C89를 지칭하기 위해 사용되던 “ANSI C”, “ANSI/ISO C”, “ISO C”라는 용어들은 이제 두 가지 표준이 존재함에 따라 모호해졌다.

C99가 아직 보편화되지 않았고, 이전 버전의 C로 작성된 수백만(혹은 수십억) 줄의 코드를 유지해야 할 필요가 있기 때문에, 나는 C99에서 추가된 기능들에 대한 논의를 특별한 아이콘(왼쪽 여백에 표시됨)으로 표시할 것이다. 이러한 기능을 인식하지 못하는 컴파일러는 “C99 호환”이 아니다. 과거의 사례로 미루어 보면, 모든 C 컴파일러가 C99 호환이 되려면 앞으로 몇 년은 더 걸릴 것이며, 어쩌면 영원히 그렇게 되지 않을 수도 있다. 부록 B는 C99와 C89 사이의 주요 차이점을 나열한다.

C 기반 언어들
C는 현대 프로그래밍 언어에 막대한 영향을 끼쳤으며, 많은 언어들이 C에서 많은 것을 차용했다. 이 중 몇 가지 특히 두드러진 C 기반 언어들은 다음과 같다:

C++: C의 모든 기능을 포함하고 있으며, 객체 지향 프로그래밍을 지원하기 위한 클래스 및 기타 기능들을 추가했다.

Java: C++을 기반으로 하고 있어 많은 C 기능들을 계승했다.

C#: C++과 Java로부터 파생된, 보다 최근의 언어이다.

Perl: 원래는 꽤 단순한 스크립팅 언어였지만, 시간이 지나며 많은 C의 기능들을 채택했다.

이러한 최신 언어들의 인기를 고려할 때, C를 배우는 것이 과연 가치 있는 일인지 의문을 제기하는 것이 논리적이다. 나는 그렇다고 생각한다. 이유는 몇 가지가 있다. 첫째, C를 배우면 C++, Java, C#, Perl 및 기타 C 기반 언어들의 기능에 대해 더 깊이 이해할 수 있다. 이러한 언어 중 하나를 먼저 배운 프로그래머는 C로부터 계승된 기본적인 기능들을 제대로 익히지 못하는 경우가 많다. 둘째, 여전히 많은 오래된 C 프로그램들이 존재하며, 당신은 이 코드를 읽고 유지보수할 필요가 있을 수도 있다. 셋째, C는 여전히 새로운 소프트웨어 개발에 널리 사용되며, 특히 메모리나 처리 능력이 제한된 상황, 혹은 C의 단순성이 바람직한 상황에서 그렇다.

당신이 이미 최신 C 기반 언어 중 하나를 사용해 본 적이 없다면, 이 책은 이러한 언어들을 배우기 위한 훌륭한 준비서가 될 것이다. 이 책은 데이터 추상화, 정보 은닉, 그리고 객체 지향 프로그래밍에서 중요한 역할을 하는 다른 원칙들을 강조한다. C++은 C의 모든 기능을 포함하고 있으므로, 나중에 C++을 배우게 될 경우 이 책에서 배운 모든 내용을 활용할 수 있을 것이다. C의 많은 기능은 다른 C 기반 언어에서도 찾아볼 수 있다.

## _**1.2 C의 강점과 약점**_
다른 모든 프로그래밍 언어들처럼, C도 강점과 약점을 가지고 있다. 둘 다 이 언어의 원래 용도(운영 체제 및 기타 시스템 소프트웨어 작성)와 그 근본적인 철학에서 비롯된다:

C는 저수준 언어다. 시스템 프로그래밍에 적합한 언어가 되기 위해, C는 다른 프로그래밍 언어들이 감추려고 하는 머신 수준 개념(예: 바이트와 주소)에 접근할 수 있게 해준다. C는 또한 컴퓨터의 내장 명령어와 밀접하게 일치하는 연산을 제공하기 때문에 프로그램의 실행 속도가 빠를 수 있다. 응용 프로그램들이 입출력, 저장소 관리, 그리고 수많은 다른 서비스들을 운영 체제에 의존하기 때문에, 운영 체제가 느려서는 안 된다.

C는 작은 언어다. C는 많은 언어들보다 제한된 기능 집합을 제공한다. (K&R의 두 번째 판에 있는 참조 매뉴얼은 전체 언어를 49쪽에 걸쳐 다룬다.) 기능의 수를 적게 유지하기 위해, C는 표준 함수들의 "라이브러리"에 크게 의존한다. ("함수"는 다른 프로그래밍 언어에서 "프로시저", "서브루틴", 또는 "메서드"라고 불릴 수 있는 것과 유사하다.)

C는 관대한 언어다. C는 당신이 무엇을 하고 있는지 안다고 가정하기 때문에, 다른 많은 언어들보다 더 큰 재량을 허용한다. 게다가 C는 다른 언어들에서 발견되는 세밀한 오류 검사를 요구하지 않는다.

### **강점**
C의 강점은 이 언어가 왜 그렇게 인기를 얻게 되었는지를 설명해준다:

효율성. 효율성은 C의 초창기부터 장점 중 하나였다. C는 전통적으로 어셈블리 언어가 사용되던 응용 프로그램을 위해 설계되었기 때문에, C 프로그램이 빠르게 실행되고 적은 메모리로 동작할 수 있어야 했다.

이식성. 비록 프로그램의 이식성이 C의 주된 목표는 아니었지만, 결과적으로 그것은 이 언어의 강점 중 하나가 되었다. 프로그램이 PC에서부터 슈퍼컴퓨터까지 다양한 컴퓨터에서 실행되어야 할 경우, 종종 C로 작성된다. C 프로그램이 이식성을 갖춘 데에는 몇 가지 이유가 있다—C가 유닉스와 밀접한 관계를 가졌고, 이후 ANSI/ISO 표준이 등장했기 때문에, 언어가 호환되지 않는 방언들로 분열되지 않았다. 또 하나는 C 컴파일러가 작고 작성이 쉬워 널리 보급될 수 있었다는 점이다. 마지막으로, C 자체도 이식성을 지원하는 기능들을 갖추고 있다(물론, 프로그래머가 이식성 없는 프로그램을 작성하지 못하게 막는 것은 아니다).

파워. C의 다양한 데이터 타입들과 연산자들은 이 언어를 강력하게 만들어준다. C에서는 몇 줄의 코드만으로 많은 것을 해낼 수 있는 경우가 흔하다.

유연성. 비록 C는 원래 시스템 프로그래밍을 위해 설계되었지만, 이 영역에만 제한되는 고유한 제약은 없다. C는 이제 임베디드 시스템부터 상업용 데이터 처리까지 모든 종류의 응용 프로그램에 사용되고 있다. 게다가, C는 그 기능들의 사용에 거의 제한을 두지 않는다. 다른 언어들에서는 불법인 연산들이 C에서는 종종 허용된다. 예를 들어, C는 문자(char)를 정수값에 더할 수 있게 해준다(혹은 실수에도). 이런 유연성은 프로그래밍을 더 쉽게 만들 수 있지만, 때로는 일부 버그가 스며들게 만들기도 한다.

표준 라이브러리. C의 가장 큰 강점 중 하나는 표준 라이브러리다. 표준 라이브러리에는 입출력, 문자열 처리, 저장소 할당, 그리고 다른 유용한 연산을 위한 수백 개의 함수가 포함되어 있다.

유닉스와의 통합. C는 유닉스(인기 있는 변종인 리눅스를 포함하여)와 결합될 때 특히 강력하다. 사실, 일부 유닉스 도구는 사용자가 C를 알고 있다는 것을 전제로 한다.

### **약점**
C의 약점은 그 많은 강점과 동일한 근원에서 비롯된다: 머신에 가까운 언어라는 점이다. 다음은 C의 가장 악명 높은 문제들 중 일부다:

C 프로그램은 오류를 유발하기 쉽다. C의 유연성은 그것을 오류 발생이 쉬운 언어로 만든다. 많은 다른 언어들에서 잡히는 프로그래밍 실수들이 C 컴파일러에서는 감지되지 않는다. 이 점에서, C는 대부분의 오류가 프로그램 실행 시에야 드러나는 어셈블리 언어와 매우 유사하다. 더 나쁜 것은, C는 조심하지 않으면 빠지기 쉬운 함정들을 다수 포함하고 있다는 것이다. 이후 장들에서, 세미콜론 하나만으로 무한 루프가 생기거나, 빠진 & 기호 하나로 인해 프로그램이 크래시 날 수 있는 예들을 보게 될 것이다.

C 프로그램은 이해하기 어렵다. C는 대부분의 기준으로 보면 작은 언어지만, 다른 프로그래밍 언어들에는 없는 여러 기능들을 갖추고 있다(그리고 그 때문에 종종 오해를 낳는다). 이 기능들은 매우 다양한 방식으로 조합될 수 있으며, 이러한 조합들은 프로그램의 원 저자에게는 명백하겠지만 다른 사람에게는 이해하기 어려울 수 있다. 또 하나의 문제는 C 프로그램의 간결한 특성이다. C는 컴퓨터와의 대화형 커뮤니케이션이 매우 불편하던 시기에 설계되었기 때문에, 프로그램 입력 및 편집에 필요한 시간을 최소화하기 위해 일부러 간결하게 유지되었다. C의 유연성 또한 단점이 될 수 있다; 과도하게 “영리한” 프로그래머들은 프로그램을 거의 이해 불가능하게 만들 수 있다.

C 프로그램은 수정하기 어렵다. 유지보수를 염두에 두지 않고 작성된 C로 된 대형 프로그램은 변경하기 어렵다. 현대적인 프로그래밍 언어들은 보통 클래스를 포함하거나 패키지를 지원함으로써, 대규모 프로그램을 보다 관리하기 쉬운 단위로 나눌 수 있게 해준다. C는 안타깝게도 이러한 기능들을 갖추고 있지 않다.

> _**난독화된 C (Obfuscated C)**_
C의 가장 열렬한 팬들조차도 C 코드가 읽기 어렵다는 사실을 인정한다. 매년 열리는 *국제 난독화 C 코드 대회(International Obfuscated C Code Contest)*는 참가자들에게 가능한 한 혼란스러운 C 프로그램을 작성하도록 장려한다. 1990년의 “최우수 소형 프로그램”은 정말로 당혹스럽다:
```c
v,i,j,k,l,s,a[99];
main()
{
 for(scanf("%d",&s);*a-s;v=a[j*=v]-a[i],k=i<s,j+=(v=j<s&&
 (!k&&!!printf(2+"\n\n%c"-(!l<<!j)," #Q"[l^v?(l^j)&1:2])&&
 ++l||a[i]<s&&v&&v-i+j&&v+i-j))&&!(l%=s),v||(i==j?a[i+=k]=0:
 ++a[i])>=s*k&&++a[--i])
 ;
}
```
이 프로그램은 도론 오소블란스키(Doron Osovlanski)와 바루흐 니센바움(Baruch Nissenbaum)이 작성했으며, 여덟 개의 퀸이 서로 공격하지 않도록 체스판 위에 놓는 “8퀸 문제”의 모든 해답을 출력한다. 실제로는 4부터 99까지의 퀸 수에 대해서도 동작한다. 더 많은 수상작은 대회 웹사이트 www.ioccc.org에서 볼 수 있다.

### **C의 효과적인 사용**
C를 효과적으로 사용하려면 C의 강점을 활용하면서 그 약점은 피해야 한다. 다음은 몇 가지 제안들이다:

C의 함정을 피하는 법을 배우라. 함정을 피하는 요령은 이 책 전체에 걸쳐 흩어져 있다—기호
를 찾아보라. 보다 광범위한 함정 목록은 Andrew Koenig의 C Traps and Pitfalls (Reading, Mass.: Addison-Wesley, 1989)을 참조하라. 현대적인 컴파일러들은 일반적인 함정들을 감지하고 경고를 출력하지만, 모든 함정을 다 감지하지는 못한다.

프로그램을 더 신뢰할 수 있게 만들기 위해 소프트웨어 도구를 사용하라. C 프로그래머들은 도구를 만들고 사용하는 데 능숙하다. 가장 유명한 C 도구 중 하나는 lint다. lint는 전통적으로 유닉스에 제공되며, 대부분의 C 컴파일러보다 더 광범위한 오류 분석을 수행할 수 있다. lint(또는 유사 프로그램)가 있다면 사용하는 것이 좋다. 또 하나의 유용한 도구는 디버거다. C의 특성상 많은 버그는 컴파일러에 의해 감지되지 않으며, 실행 중 오류나 잘못된 출력으로 나타난다. 따라서, 좋은 디버거를 사용하는 것은 사실상 필수적이다.

기존 코드 라이브러리를 활용하라. C를 사용하는 이점 중 하나는 수많은 다른 사람들이 이미 사용하고 있다는 것이다; 그들이 작성한 코드를 여러분이 활용할 수 있는 가능성이 크다. C 코드는 종종 함수들의 모음인 라이브러리 형태로 제공된다; 적절한 라이브러리를 확보하는 것은 오류를 줄이고 상당한 프로그래밍 작업을 줄이는 좋은 방법이다. 사용자 인터페이스 개발, 그래픽, 통신, 데이터베이스 관리, 네트워킹 등 일반적인 작업을 위한 라이브러리는 쉽게 구할 수 있다. 어떤 라이브러리는 퍼블릭 도메인이고, 어떤 것은 오픈 소스이며, 또 어떤 것은 상업적으로 판매된다.

합리적인 코딩 규칙을 채택하라. 코딩 규칙은 언어가 강제하지는 않지만 프로그래머가 채택하기로 결정한 스타일 규칙이다. 잘 선택된 규칙은 프로그램을 더 일관되게 만들고, 읽기 쉽고, 수정하기 쉽게 만든다. 어떤 프로그래밍 언어를 사용할 때든 규칙은 중요하지만, 특히 C에서는 더 그렇다. 앞서 언급했듯이, C는 매우 유연하기 때문에 프로그래머가 거의 읽을 수 없는 코드를 작성할 수 있다. 이 책의 프로그래밍 예제들은 하나의 규칙을 따른다. 하지만, 다른 방식도 존재하며, 그것들도 똑같이 유효하다. 어떤 규칙을 사용할지는 중요하지 않다. 중요한 것은 어떤 규칙이든 채택하고, 그것을 지키는 것이다.

“트릭”이나 지나치게 복잡한 코드를 피하라. C는 프로그래밍 트릭을 장려하는 언어다. 어떤 작업을 수행하는 방법은 보통 여러 가지가 있으며, 프로그래머는 종종 가장 간결한 방법을 선택하고 싶어진다. 너무 과하게 빠지지 말라; 가장 짧은 해결책이 가장 이해하기 어려운 경우가 많다. 이 책에서는 비교적 간결하지만 여전히 이해 가능한 스타일을 소개할 것이다.

표준을 따르라. 대부분의 C 컴파일러는 C89나 C99 표준에 포함되지 않은 언어 기능이나 라이브러리 함수를 제공한다. 이식성을 위해서는, 꼭 필요한 경우가 아니라면 비표준 기능이나 라이브러리를 사용하는 것을 피하는 것이 최선이다.

## _**Q&A**_
Q: 이 Q&A 섹션은 무엇을 위한 것인가요?
A: 좋은 질문이다. Q&A 섹션은 각 장의 끝에 등장하며 여러 목적을 갖는다.
Q&A의 주된 목적은 C를 배우는 학생들이 자주 묻는 질문들을 다루는 것이다. 독자들은 저자와 일종의 대화를 나누는 느낌을 받을 수 있다. 마치 내가 진행하는 C 수업 중 하나에 참석한 것처럼 말이다.
또 다른 목적은 장에서 다룬 주제들에 대해 추가적인 정보를 제공하는 것이다. 이 책의 독자들은 배경이 매우 다양할 것이다. 어떤 독자들은 다른 프로그래밍 언어에 능숙할 수 있고, 어떤 사람들은 처음으로 프로그래밍을 배우는 중일 수도 있다. 다양한 언어 경험을 가진 독자들은 간단한 설명과 몇 가지 예제에 만족할 수 있지만, 경험이 적은 독자들은 더 많은 설명이 필요할 수 있다. 결론: 어떤 주제의 설명이 부족하다고 느껴진다면, Q&A를 확인해보라.

가끔, Q&A는 C 컴파일러들 간의 일반적인 차이점에 대해 다룰 것이다. 예를 들어, 특정 컴파일러들이 제공하는 자주 사용되지만 비표준인 기능에 대해서 다룰 것이다.

Q: lint는 무엇을 하나요? [p. 6]
A: lint는 C 프로그램에서 수많은 잠재적 오류를 검사한다. 여기에는—하지만 이것에만 국한되지 않고—수상한 타입 조합, 사용되지 않는 변수, 도달할 수 없는 코드, 비이식성 코드 등이 포함된다. lint는 진단 메시지 목록을 출력하고, 프로그래머는 그 목록을 검토해야 한다. lint를 사용하는 장점은 컴파일러가 놓치는 오류들을 감지할 수 있다는 것이다. 단점은 lint를 잊지 않고 써야 한다는 점이다; 너무 쉽게 잊을 수 있다. 더 나쁜 것은, lint가 수백 개의 메시지를 출력할 수 있는데, 이 중 실제 오류에 해당하는 것은 소수일 수도 있다.

Q: lint는 왜 그렇게 이름이 붙여졌나요?
A: 다른 많은 유닉스 도구들과는 달리, lint는 약어가 아니다. 이 이름은 프로그램에서 “보풀(fluff)” 같은 조각들을 찾아내는 방식에서 유래되었다.

Q: lint는 어디서 구할 수 있나요?
A: lint는 표준 유닉스 유틸리티다; 다른 운영 체제를 사용하는 경우 lint가 없을 수도 있다. 다행히도, 타사로부터 lint의 여러 버전을 구할 수 있다. splint(보안 프로그래밍 Lint)라는 향상된 버전은 많은 리눅스 배포판에 포함되어 있으며 www.splint.org에서 무료로 다운로드할 수 있다.

Q: lint 없이도 컴파일러가 더 철저한 오류 검사를 하도록 강제할 수 있는 방법이 있나요?
A: 있다. 대부분의 컴파일러는 요청하면 프로그램을 더 철저하게 검사한다. 오류(명백한 규칙 위반)를 검사하는 것 외에도, 대부분의 컴파일러는 경고 메시지를 출력하여 잠재적인 문제 지점을 알려준다. 어떤 컴파일러들은 “경고 수준”을 여러 단계로 제공하는데, 더 높은 수준을 선택하면 더 많은 문제를 검사하게 된다. 컴파일러가 경고 수준을 지원한다면, 가장 높은 수준을 선택하는 것이 좋다. 그러면 컴파일러는 가능한 한 철저한 검사를 수행할 것이다. GCC 컴파일러의 오류 검사 옵션은 2장에서 Q&A 섹션에서 다룬다.

Q: 제 프로그램을 최대한 신뢰할 수 있게 만들고 싶은데, lint나 디버거 외에 다른 도구가 있나요?
A: 있다. 다른 일반적인 도구로는 “바운드 검사기(bounds-checkers)”와 “메모리 누수 탐지기(leak-finders)”가 있다. C는 배열 첨자가 범위를 벗어나는지 검사하지 않기 때문에, 바운드 검사기는 이 기능을 추가해준다. 메모리 누수 탐지기는 “메모리 누수”—즉, 동적으로 할당되었지만 해제되지 않은 메모리 블록—를 찾아주는 데 도움을 준다.

* 별표가 있는 질문들은 평균 독자에게는 너무 고급이거나 지나치게 특이한 주제를 다루며, 종종 이후 장에서 다룰 내용과 관련 있다. 프로그래밍 경험이 풍부한 호기심 많은 독자들은 이러한 질문들을 지금 바로 살펴볼 수도 있겠지만, 다른 독자들은 처음 읽을 때에는 생략하는 것이 좋다.