---
title: 2. 리스트
date: 2025-04-14
math: true
categories: [알고리즘] 
tags: [자료구조, 알고리즘] 
---

_리스트_ 는 다재다능한 데이터 구조이며 파이썬의 주요 데이터 구조입니다. 프로그램에서 처리하는 데이터는 대부분 리스트에 저장되지만, 다른 데이터 구조가 더 적합한 상황도 있습니다.

이 장에서는 파이썬 리스트의 구현과 속성을 살펴봅니다. 특히 리스트 연산의 시간 복잡도에 중점을 둡니다. 어떤 연산이 효율적이고 언제 리스트를 사용해야 하는지에 대해 알아봅니다.

# 메모리 내의 리스트 #
컴퓨터의 메모리는 데이터를 저장할 수 있는 메모리 위치의 연속된 시퀀스로 구성됩니다. 각 메모리 위치에는 접근에 사용할 수 있는 주소가 있습니다. 프로그램이 실행되면 프로그램이 처리하는 데이터는 메모리에 저장됩니다.

다음 파이썬 프로그램을 예로 들어 보겠습니다.

```py
a = 7
b = -3
c = [1, 2, 3, 1, 2]
d = 99
```

프로그램에 정의된 변수와 리스트가 주소 100부터 시작하는 메모리에 저장된다고 가정해 보겠습니다. 다음은 이 상황에서 메모리 내용이 어떻게 보일 수 있는지 단순화한 그림입니다.


|100 |101 |102 |103 |104 |105 |106 |107 |108 |109 |110
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:
|7  |-3  |1   |2   |3   |1   |2   |0   |0   |0  |99
|a  |b   |c   |    |    |    |    |    |    |   |d


여기서 변수 `a`의 내용은 메모리 위치 100에 저장되고 변수 `b`의 내용은 위치 101에 저장됩니다. 메모리 위치 102-109는 리스트 `c`를 위해 예약되었지만, 리스트에 5개의 요소만 있으므로 현재는 위치 102-106만 사용 중입니다. 변수 `d`의 내용은 위치 110에 있습니다.

리스트의 요소는 연속된 메모리 위치에 저장되어 특정 리스트 요소의 위치를 쉽게 결정할 수 있습니다. 요소의 메모리 주소는 첫 번째 요소의 주소에 요소 인덱스를 더하여 얻습니다. 예를 들어 위 상황에서 요소 `c[2]`는 주소 102 + 2 = 104에 있습니다.

위에서 언급했듯이 리스트는 현재 요소에 필요한 것보다 더 많은 메모리를 차지합니다. 추가 메모리의 이유는 리스트에 새로운 요소를 추가할 가능성에 대비하기 위함입니다. 따라서 리스트에는 두 가지 크기가 있습니다. 요소의 수(여기서는 5)와 리스트를 위해 예약된 메모리 위치의 수(여기서는 8)입니다.

# 리스트 연산 #
파이썬에는 리스트를 관리하기 위한 여러 내장 연산이 있습니다. 다음으로 리스트에 $n$개의 요소가 있다고 가정하고 시간 복잡도 관점에서 이러한 연산의 효율성을 살펴보겠습니다.

리스트 연산의 시간 복잡도를 아는 것은 효율적인 알고리즘의 구성 요소로 어떤 연산을 사용할 수 있는지 결정하므로 알고리즘 설계에 중요합니다. 대부분의 리스트 연산은 다음 시간 복잡도 중 하나를 가집니다.


- $O(1)$: 연산은 리스트의 크기에 관계없이 항상 효율적입니다.</li>
- $O(n)$: 효율성은 리스트의 크기에 따라 달라지며 큰 리스트의 경우 느릴 수 있습니다.</li>


## 인덱싱 ##
인덱스 연산자 `[]`를 사용하여 리스트의 요소에 접근하고 수정할 수 있습니다.

```py
numbers = [4, 3, 7, 3, 2]
print(numbers[2]) # 7
numbers[2] = 5
print(numbers[2]) # 5
```

요소는 연속된 메모리 위치에 있고 요소의 주소를 빠르게 계산할 수 있으므로 접근 또는 수정에는 $O(1)$ 시간이 걸립니다.

## 리스트 크기 ##
함수 `len`은 리스트에 포함된 요소의 수를 알려줍니다.

```py
numbers = [4, 3, 7, 3, 2]
print(len(numbers)) # 5
```

길이는 리스트와 함께 메모리에 저장되므로 함수는 $O(1)$ 시간이 걸립니다.

## 검색 ##
연산자 `in`은 주어진 요소가 리스트에 있는지 여부를 알려줍니다. 메서드 `index`는 리스트에서 요소가 처음 나타나는 인덱스를 반환합니다. 메서드 `count`는 리스트에서 요소의 발생 횟수를 세어줍니다.

```py
numbers = [4, 3, 7, 3, 2]

print(3 in numbers) # True
print(8 in numbers) # False

print(numbers.index(3)) # 1
print(numbers.count(3)) # 2
```

이러한 모든 연산은 리스트를 검색해야 하므로 $O(n)$ 시간이 걸립니다. 예를 들어 메서드 `count`는 기본적으로 루프를 사용하여 요소를 순회하는 다음 함수와 같이 작동합니다.

```py
def count(items, target):
    result = 0
    for item in items:
        if item == target:
            result += 1
    return result
```

일부 연산은 특정 상황에서는 속도가 빠를 수 있습니다. 예를 들어, 찾고자 하는 요소가 리스트의 맨 앞에 있는 경우, 해당 요소를 발견하는 즉시 멈출 수 있으므로 'in' 연산자는 빠릅니다. 그러나 최악의 경우 요소가 리스트에 없고 연산은 이를 확인하기 위해 전체 리스트를 순회해야 합니다.

## 요소 추가 ##
메서드 `append`는 리스트의 끝에 요소를 추가하고, 메서드 `insert`는 리스트의 주어진 위치에 요소를 추가합니다.

```py
numbers = [1, 2, 3, 4]

numbers.append(5)
print(numbers) # [1, 2, 3, 4, 5]

numbers.insert(1, 6)
print(numbers) # [1, 6, 2, 3, 4, 5]
```

이러한 연산의 시간 복잡도는 요소가 메모리에 저장되는 방식에 영향을 받습니다. 이 경우 추가 전의 메모리 내용은 다음과 같습니다:

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |2   |3   |4   |0   |0   |0   |0


메서드 `append`는 리스트의 끝에 요소를 추가하는 데 다른 메모리 위치의 변경이 필요하지 않으므로 $O(1)$ 시간이 걸립니다. 예시에서 요소 `5`는 메모리 위치 104에 저장됩니다.

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |2   |3   |4   |5   |0   |0   |0

리스트를 위해 예약된 메모리 영역이 이미 꽉 차서 새 요소를 위한 공간이 없으면 더 많은 작업이 필요합니다. 이러한 경우 새롭고 더 큰 메모리 영역이 리스트를 위해 예약되고 모든 요소가 새 영역으로 이동되며 이는 $O(n)$ 시간이 걸립니다. 그러나 [적절한 구현](https://tira.mooc.fi/spring-2025/list-addition)을 통해 이러한 상황은 매우 드물게 발생하도록 만들 수 있으며, `append` 메서드의 평균 시간 복잡도는 $O(1)$입니다.

메서드 `insert`는 리스트의 끝이 아닌 다른 위치에 요소를 추가할 때 다른 요소들을 뒤로 이동시켜 새 요소를 위한 공간을 만들어야 하므로 $O(n)$의 시간 복잡도를 가집니다. 예시에서 요소 `6`이 인덱스 `1`에 삽입되면 요소는 다음과 같이 재배치됩니다.

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |6   |2   |3   |4   |5   |0   |0

그러나 요소가 리스트의 끝 근처의 어딘가에 삽입되면 재배치해야 하는 요소의 수가 적기 때문에 `insert` 메서드는 효율적이라는 점에 유의하십시오.

# 요소 제거 #

메서드 `pop`은 리스트에서 요소를 제거합니다. 파라미터 없이 메서드가 호출되면 마지막 요소를 제거합니다. 파라미터가 주어지면, 해당 인덱스에 있는 요소를 제거합니다.

```py
numbers = [1, 2, 3, 4, 5, 6]

numbers.pop()
print(numbers) # [1, 2, 3, 4, 5]
numbers.pop(1)

print(numbers) # [1, 3, 4, 5]
```

요소 제거가 메모리의 내용에 어떻게 영향을 미치는지 다시 한번 살펴봅시다. 제거 전 메모리의 내용은 다음과 같을 수 있습니다:

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |2   |3   |4   |5   |6   |0   |0

추가와 마찬가지로, 리스트의 끝에서 요소를 제거하는 것은 다른 요소에 영향을 미치지 않으므로 $O(1)$ 시간이 걸립니다. 요소 `6`을 제거한 후 메모리는 다음과 같을 수 있습니다:

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |2   |3   |4   |5   |0   |0   |0

리스트의 중간에서 요소를 제거하는 것은 $O(n)$ 시간이 걸립니다. 왜냐하면 이제 뒤따르는 모든 요소들이 메모리에서 재배치되어야 하기 때문입니다. 요소 `2`를 제거하는 것은 메모리 내용에 다음과 같은 영향을 미칩니다:

|100 |101 |102 |103 |104 |105 |106 |107
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |3   |4   |5   |0   |0   |0    |0

파이썬은 주어진 요소의 첫 번째 항목을 제거하는 리스트 메서드 `remove`도 가지고 있습니다:

```py
numbers = [1, 2, 3, 1, 2, 3]

numbers.remove(3)
print(numbers) # [1, 2, 1, 2, 3]
```

이 메서드의 시간 복잡도는 항상 $O(n)$입니다. 왜냐하면 먼저 첫 번째 항목을 찾아야 하고 (메서드 `index`와 유사하게), 그런 다음 요소를 제거하고 뒤따르는 요소들을 재배치해야 하기 때문입니다.

## 요약 ##

다음 표는 지금까지 살펴본 연산들의 시간 복잡도를 요약한 것입니다:

<table>
    <thead>
        <tr>
            <th>연산</th>
            <th>시간 복잡도</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>인덱싱 ([])</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>크기 (len)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>요소가 리스트에 있는지? (in)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>검색 (index)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>개수 세기 (count)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>끝에 추가 (append)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>중간에 추가 (insert)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>끝에서 제거 (pop)</td>
            <td>O(1)</td>
        </tr>
        <tr>
            <td>중간에서 제거 (pop)</td>
            <td>O(n)</td>
        </tr>
        <tr>
            <td>검색 후 제거 (remove)</td>
            <td>O(n)</td>
        </tr>
    </tbody>
</table>

따라서 효율적인 연산은 인덱싱, 크기 조회, 그리고 리스트의 끝에 요소를 추가하고 제거하는 것입니다. 리스트는 대부분의 연산이 이들에 속하고, 다른 더 비용이 많이 드는 연산이 드문 경우에 적합한 자료 구조입니다.

# 참조와 복사 #

파이썬에서 리스트와 다른 자료 구조는 참조를 통해 접근됩니다. 변수에 리스트를 할당하는 것은 리스트의 내용이 아니라 참조만 복사합니다:

```py
a = [1, 2, 3, 4]
b = a
a.append(5)

print(a) # [1, 2, 3, 4, 5]
print(b) # [1, 2, 3, 4, 5]
```

여기서 `b = a` 줄을 실행하면 변수 `a`와 `b`는 메모리에서 동일한 리스트를 참조하게 됩니다. 리스트 `a`에 새로운 요소가 추가되면, 동일한 추가가 리스트 `b`에도 발생합니다.

내용을 복사하려면 메서드 `copy`를 사용할 수 있습니다:

```py
a = [1, 2, 3, 4]
b = a.copy()
a.append(5)

print(a) # [1, 2, 3, 4, 5]
print(b) # [1, 2, 3, 4]
```

이제 변수 `a`와 `b`는 서로 다른 리스트를 참조하며, 리스트 `a`에 요소를 추가해도 리스트 `b`의 내용에는 영향을 미치지 않습니다.

위 연산들의 효율성에는 큰 차이가 있습니다. 참조를 복사하는 데는 $O(1)$ 시간이 걸리는 반면, 내용을 복사하는 데는 $O(n)$ 시간이 걸립니다. 따라서 `b = a` 줄은 $O(1)$ 시간이 걸리고, `b = a.copy()` 줄은 $O(n)$ 시간이 걸립니다.

## 함수의 부작용 ##

함수에 자료 구조가 매개변수로 주어지면, 참조만 복사됩니다. 그러면 함수는 자료 구조의 내용을 변경하여 _부작용_ 을 일으킬 수 있습니다.

각 요소의 값이 두 배가 된 리스트를 반환하는 다음 함수 `double`을 고려해 봅시다.

```py
def double(numbers):
    result = numbers
    for i in range(len(result)):
        result[i] *= 2
    return result
```

참조만 복사되기 때문에, 이 함수는 매개변수로 받은 리스트를 변경합니다.

```py
numbers = [1, 2, 3, 4]
print(double(numbers)) # [2, 4, 6, 8]
print(numbers) # [2, 4, 6, 8]
```

원래 리스트를 변경하지 않고 새로운 리스트를 만들려는 의도일 때는 이것이 좋지 않습니다. `copy` 메서드를 사용하여 함수를 수정할 수 있습니다.

```py
def double(numbers):
    result = numbers.copy()
    for i in range(len(result)):
        result[i] *= 2
    return result
```

이제 원래 리스트의 내용은 변경되지 않습니다.

```py
numbers = [1, 2, 3, 4]
print(double(numbers)) # [2, 4, 6, 8]
print(numbers) # [1, 2, 3, 4]
```


## 슬라이싱과 연결 ##

파이썬 슬라이스 연산자(`[:]`)는 주어진 리스트의 일부를 복사한 새로운 리스트를 만듭니다.

```py
numbers = [1, 2, 3, 4, 5, 6, 7, 8]
print(numbers[2:6]) # [3, 4, 5, 6]
```

이 연산자는 이전 리스트의 내용을 새 리스트로 복사하기 때문에 $O(n)$ 시간이 걸립니다.

슬라이스 연산자는 요소를 복사하므로 전체 리스트의 내용을 복사하는 데에도 사용할 수 있습니다. 다음 두 줄은 동일합니다:

```py
result = numbers.copy()
```

```py
result = numbers[:]
```

`+` 연산자는 리스트를 연결하는 데 사용할 수 있습니다.

```py
first = [1, 2, 3, 4]
second = [5, 6, 7, 8]
print(first + second) # [1, 2, 3, 4, 5, 6, 7, 8]
```

이것은 원래 리스트의 요소를 새 리스트로 복사하기 때문에 O(n) 시간이 걸립니다.

# 다른 언어의 리스트 #

이 장에서 설명된 리스트는 일반적으로 <dfn>배열 리스트</dfn> 또는 <dfn>동적 배열</dfn>이라고 더 잘 알려져 있습니다.

C++ 및 Java와 같은 저수준 언어에서는 기본 자료 구조가 일반적으로 _배열_ 입니다. 리스트와 마찬가지로 배열은 인덱싱으로 접근할 수 있는 연속된 요소의 시퀀스입니다. 그러나 배열은 생성될 때 고정된 메모리 영역이 할당되며 나중에 크기를 변경할 수 없습니다. 가변 크기가 필요한 경우 이러한 언어에는 다른 자료 구조가 있습니다.

C++에서 `std::vector` 자료 구조는 리스트를 구현합니다.

```cpp
std::vector<int> numbers;

numbers.push_back(1);
numbers.push_back(2);
numbers.push_back(3);
```

그리고 Java에서 `ArrayList` 자료 구조는 리스트를 구현합니다.

```java
ArrayList<Integer> numbers = new ArrayList<>();

numbers.add(1);
numbers.add(2);
numbers.add(3);
```

JavaScript에서 기본 자료 구조는 `Array`라고 불리지만, 크기를 변경할 수 있으므로 실제로는 리스트입니다.

```js
numbers = [];

numbers.push(1);
numbers.push(2);
numbers.push(3);
```
